{"head":{"layout":"Post","comments":true,"date":"2015-12-07","title":"ES6, ES2015 : Object.assign","tags":["JavaScript","ES6","ES2015"],"authors":["naholyr"],"translators":["MoOx"]},"body":"<p>You probably know underscore or lodash <code>extend</code> method (at leat lodash right)?\nLike most of these utilities functions, those are deprecated by an ES6 (ES2015)\nfeature.</p>\n<h1 id=\"object-assign\"><a class=\"markdownIt-Anchor\" href=\"#object-assign\">#</a> Object.assign</h1>\n<p>The new static method <code>Object.assign</code> take a bunch of objects as arguments :</p>\n<ul>\n<li>The first is a target for copies;</li>\n<li>Next are sources;</li>\n<li>All <em>own properties</em> (enumerable keys and non inherited, even those which are\n<code>undefined</code>) will be copied  in the target (so last ones take precedences);</li>\n<li><strong>The target object is modified</strong> (it must be mutable);</li>\n<li>The modified target object is returned.</li>\n</ul>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> o = { y: <span class=\"hljs-number\">0</span> }\n<span class=\"hljs-keyword\">const</span> o1 = { x: <span class=\"hljs-number\">1</span>, y: <span class=\"hljs-number\">2</span> }\n<span class=\"hljs-keyword\">const</span> o2 = { x: <span class=\"hljs-literal\">undefined</span>, z: <span class=\"hljs-number\">3</span> }\n<span class=\"hljs-built_in\">Object</span>.assign(o, o1, o2) <span class=\"hljs-comment\">// { x: undefined, y: 2, z: 3 }</span>\no <span class=\"hljs-comment\">// { x: undefined, y: 2, z: 3 }</span>\no1 <span class=\"hljs-comment\">// unmodified</span>\no2 <span class=\"hljs-comment\">// unmodified</span></code></pre>\n<h2 id=\"becareful-to-mutability\"><a class=\"markdownIt-Anchor\" href=\"#becareful-to-mutability\">#</a> Becareful to mutability</h2>\n<p>Be warned that the target is always modified.\nSince the most frequent use-case is the creation of a new object that will be\ngenerated from others sources, most of the time we will pass an new empty object\nas the first parameter.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> o1 = { x: <span class=\"hljs-number\">1</span> }\n<span class=\"hljs-keyword\">const</span> o2 = { y: <span class=\"hljs-number\">2</span> }\n<span class=\"hljs-keyword\">const</span> o = <span class=\"hljs-built_in\">Object</span>.assign({}, o1, o2)\no <span class=\"hljs-comment\">// { x: 1, y: 2 }</span>\n<span class=\"hljs-comment\">// o1 and o2 are unmodified</span></code></pre>\n<h2 id=\"specific-use-cases\"><a class=\"markdownIt-Anchor\" href=\"#specific-use-cases\">#</a> Specific use-cases</h2>\n<h3 id=\"error-during-the-copy\"><a class=\"markdownIt-Anchor\" href=\"#error-during-the-copy\">#</a> Error during the copy</h3>\n<p>If a property in the target is read-only, <code>Object.assign</code> should behave like\nin strict mode (unlike the <em>wtf</em> mode) and throw an error before stoping the\ncopy.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> o = <span class=\"hljs-built_in\">Object</span>.create({}, {\n  val: { value: <span class=\"hljs-number\">42</span>, enumerable: <span class=\"hljs-literal\">true</span>, writable: <span class=\"hljs-literal\">false</span> }\n})\n\n<span class=\"hljs-comment\">// \"standard\" (wtf) mode:</span>\no.val = <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">// no error</span>\no.val <span class=\"hljs-comment\">// 42 (unmodified value)</span>\n<span class=\"hljs-built_in\">Object</span>.assign(o, { x: <span class=\"hljs-number\">1</span>, val: <span class=\"hljs-number\">0</span>, y: <span class=\"hljs-number\">2</span> }) <span class=\"hljs-comment\">// Uncaught TypeError: Cannot assign…</span>\no <span class=\"hljs-comment\">// { val: 42, x: 1 }</span>\n\n<span class=\"hljs-comment\">// \"strict\" mode:</span>\no.val = <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">// Uncaught TypeError: Cannot assign…</span>\n<span class=\"hljs-built_in\">Object</span>.assign(o, { x: <span class=\"hljs-number\">1</span>, val: <span class=\"hljs-number\">0</span>, y: <span class=\"hljs-number\">2</span> }) <span class=\"hljs-comment\">// Uncaught TypeError: Cannot assign…</span>\no <span class=\"hljs-comment\">// { val: 42, x: 1 }</span></code></pre>\n<p>Keys that have already been copied before the throwing of the exception will\nbe kept in the target object, that’s why in our example <code>x</code> have been copied\nbut not <code>y</code>.</p>\n<p>Note: this is theory, but practise show us that this behavior is variable,\ndepending of the platform and the context, the error might not always be thrown.\nTo get a predictable behavior, you should work in <em>strict</em> mode.</p>\n<h3 id=\"scalar-sources\"><a class=\"markdownIt-Anchor\" href=\"#scalar-sources\">#</a> Scalar sources</h3>\n<p>When sources are scalar values (number, boolean, etc) <code>Object.keys</code> will not\nreturn any keys and values will be ignored.\n<code>null</code> and <code>undefined</code> will also be ignored.</p>\n<p>Particular case: strings are treated as array.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> o = {}\n<span class=\"hljs-built_in\">Object</span>.assign(o, <span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-string\">\"toto\"</span>, [<span class=\"hljs-string\">\"b\"</span>, <span class=\"hljs-string\">\"a\"</span>], <span class=\"hljs-literal\">undefined</span>)\n<span class=\"hljs-comment\">// 1, true, null, undefined are ignored</span>\n<span class=\"hljs-comment\">// \"toto\" is converted to {0: \"t\", 1: \"o\", 2: \"t\", 3: \"o\"}</span>\n<span class=\"hljs-comment\">// [\"b\", \"a\"] is converted to {0: \"b\", 1: \"a\"}</span>\no <span class=\"hljs-comment\">// {0: \"b\", 1: \"a\", 2: \"t\", 3: \"o\"}</span></code></pre>\n<h2 id=\"conclusion\"><a class=\"markdownIt-Anchor\" href=\"#conclusion\">#</a> Conclusion</h2>\n<p>We can forget <code>_.clone</code>, <code>_.extend</code> and friends with this method!</p>\n<p>About compatiblity, <code>Object.assign</code> is pretty well supported by all modern\nbrowsers (IE is not considered as modern until 12) :</p>\n<ul>\n<li>Edge (IE ≥ 12) ;</li>\n<li>Chrome stable (46) ;</li>\n<li>Firefox stable (42) ;</li>\n<li>Node ≥ 4 ;</li>\n<li>If you need to support old browsers, you will need <a href=\"http://babeljs.io\">Babel</a>\nor one of many users implementations.</li>\n</ul>\n","rawBody":"\nYou probably know underscore or lodash ``extend`` method (at leat lodash right)?\nLike most of these utilities functions, those are deprecated by an ES6 (ES2015)\nfeature.\n\n# Object.assign\n\nThe new static method ``Object.assign`` take a bunch of objects as arguments :\n\n* The first is a target for copies;\n* Next are sources;\n* All *own properties* (enumerable keys and non inherited, even those which are\n  ``undefined``) will be copied  in the target (so last ones take precedences);\n* **The target object is modified** (it must be mutable);\n* The modified target object is returned.\n\n```js\nconst o = { y: 0 }\nconst o1 = { x: 1, y: 2 }\nconst o2 = { x: undefined, z: 3 }\nObject.assign(o, o1, o2) // { x: undefined, y: 2, z: 3 }\no // { x: undefined, y: 2, z: 3 }\no1 // unmodified\no2 // unmodified\n```\n\n## Becareful to mutability\n\nBe warned that the target is always modified.\nSince the most frequent use-case is the creation of a new object that will be\ngenerated from others sources, most of the time we will pass an new empty object\nas the first parameter.\n\n```js\nconst o1 = { x: 1 }\nconst o2 = { y: 2 }\nconst o = Object.assign({}, o1, o2)\no // { x: 1, y: 2 }\n// o1 and o2 are unmodified\n```\n\n## Specific use-cases\n\n### Error during the copy\n\nIf a property in the target is read-only, ``Object.assign`` should behave like\nin strict mode (unlike the *wtf* mode) and throw an error before stoping the\ncopy.\n\n```js\nconst o = Object.create({}, {\n  val: { value: 42, enumerable: true, writable: false }\n})\n\n// \"standard\" (wtf) mode:\no.val = 0 // no error\no.val // 42 (unmodified value)\nObject.assign(o, { x: 1, val: 0, y: 2 }) // Uncaught TypeError: Cannot assign…\no // { val: 42, x: 1 }\n\n// \"strict\" mode:\no.val = 0 // Uncaught TypeError: Cannot assign…\nObject.assign(o, { x: 1, val: 0, y: 2 }) // Uncaught TypeError: Cannot assign…\no // { val: 42, x: 1 }\n```\n\nKeys that have already been copied before the throwing of the exception will\nbe kept in the target object, that's why in our example ``x`` have been copied\nbut not ``y``.\n\nNote: this is theory, but practise show us that this behavior is variable,\ndepending of the platform and the context, the error might not always be thrown.\nTo get a predictable behavior, you should work in *strict* mode.\n\n### Scalar sources\n\nWhen sources are scalar values (number, boolean, etc) ``Object.keys`` will not\nreturn any keys and values will be ignored.\n``null`` and ``undefined`` will also be ignored.\n\nParticular case: strings are treated as array.\n\n```js\nconst o = {}\nObject.assign(o, 1, true, null, \"toto\", [\"b\", \"a\"], undefined)\n// 1, true, null, undefined are ignored\n// \"toto\" is converted to {0: \"t\", 1: \"o\", 2: \"t\", 3: \"o\"}\n// [\"b\", \"a\"] is converted to {0: \"b\", 1: \"a\"}\no // {0: \"b\", 1: \"a\", 2: \"t\", 3: \"o\"}\n```\n\n## Conclusion\n\nWe can forget ``_.clone``, ``_.extend`` and friends with this method!\n\nAbout compatiblity, ``Object.assign`` is pretty well supported by all modern\nbrowsers (IE is not considered as modern until 12) :\n\n* Edge (IE ≥ 12) ;\n* Chrome stable (46) ;\n* Firefox stable (42) ;\n* Node ≥ 4 ;\n* If you need to support old browsers, you will need [Babel](http://babeljs.io)\n  or one of many users implementations.\n","raw":"---\ndate: \"2015-12-07\"\ntitle: \"ES6, ES2015 : Object.assign\"\ntags:\n  - JavaScript\n  - ES6\n  - ES2015\nauthors:\n  - naholyr\ntranslators:\n  - MoOx\n---\n\nYou probably know underscore or lodash ``extend`` method (at leat lodash right)?\nLike most of these utilities functions, those are deprecated by an ES6 (ES2015)\nfeature.\n\n# Object.assign\n\nThe new static method ``Object.assign`` take a bunch of objects as arguments :\n\n* The first is a target for copies;\n* Next are sources;\n* All *own properties* (enumerable keys and non inherited, even those which are\n  ``undefined``) will be copied  in the target (so last ones take precedences);\n* **The target object is modified** (it must be mutable);\n* The modified target object is returned.\n\n```js\nconst o = { y: 0 }\nconst o1 = { x: 1, y: 2 }\nconst o2 = { x: undefined, z: 3 }\nObject.assign(o, o1, o2) // { x: undefined, y: 2, z: 3 }\no // { x: undefined, y: 2, z: 3 }\no1 // unmodified\no2 // unmodified\n```\n\n## Becareful to mutability\n\nBe warned that the target is always modified.\nSince the most frequent use-case is the creation of a new object that will be\ngenerated from others sources, most of the time we will pass an new empty object\nas the first parameter.\n\n```js\nconst o1 = { x: 1 }\nconst o2 = { y: 2 }\nconst o = Object.assign({}, o1, o2)\no // { x: 1, y: 2 }\n// o1 and o2 are unmodified\n```\n\n## Specific use-cases\n\n### Error during the copy\n\nIf a property in the target is read-only, ``Object.assign`` should behave like\nin strict mode (unlike the *wtf* mode) and throw an error before stoping the\ncopy.\n\n```js\nconst o = Object.create({}, {\n  val: { value: 42, enumerable: true, writable: false }\n})\n\n// \"standard\" (wtf) mode:\no.val = 0 // no error\no.val // 42 (unmodified value)\nObject.assign(o, { x: 1, val: 0, y: 2 }) // Uncaught TypeError: Cannot assign…\no // { val: 42, x: 1 }\n\n// \"strict\" mode:\no.val = 0 // Uncaught TypeError: Cannot assign…\nObject.assign(o, { x: 1, val: 0, y: 2 }) // Uncaught TypeError: Cannot assign…\no // { val: 42, x: 1 }\n```\n\nKeys that have already been copied before the throwing of the exception will\nbe kept in the target object, that's why in our example ``x`` have been copied\nbut not ``y``.\n\nNote: this is theory, but practise show us that this behavior is variable,\ndepending of the platform and the context, the error might not always be thrown.\nTo get a predictable behavior, you should work in *strict* mode.\n\n### Scalar sources\n\nWhen sources are scalar values (number, boolean, etc) ``Object.keys`` will not\nreturn any keys and values will be ignored.\n``null`` and ``undefined`` will also be ignored.\n\nParticular case: strings are treated as array.\n\n```js\nconst o = {}\nObject.assign(o, 1, true, null, \"toto\", [\"b\", \"a\"], undefined)\n// 1, true, null, undefined are ignored\n// \"toto\" is converted to {0: \"t\", 1: \"o\", 2: \"t\", 3: \"o\"}\n// [\"b\", \"a\"] is converted to {0: \"b\", 1: \"a\"}\no // {0: \"b\", 1: \"a\", 2: \"t\", 3: \"o\"}\n```\n\n## Conclusion\n\nWe can forget ``_.clone``, ``_.extend`` and friends with this method!\n\nAbout compatiblity, ``Object.assign`` is pretty well supported by all modern\nbrowsers (IE is not considered as modern until 12) :\n\n* Edge (IE ≥ 12) ;\n* Chrome stable (46) ;\n* Firefox stable (42) ;\n* Node ≥ 4 ;\n* If you need to support old browsers, you will need [Babel](http://babeljs.io)\n  or one of many users implementations.\n","__filename":"en/articles/js/es2015/object-assign.md","__url":"/en/articles/js/es2015/object-assign/"}