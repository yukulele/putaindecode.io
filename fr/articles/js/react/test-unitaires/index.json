{"head":{"layout":"Post","comments":true,"date":"2015-11-24","title":"Tester unitairement des composants React","tags":["js","react","tests"],"authors":["MoOx"],"header":{"image":"https://farm6.staticflickr.com/5159/7112879347_9e0da289ca_z.jpg","credit":"https://www.flickr.com/photos/dvids/7112879347","linearGradient":"160deg, rgba(0,0,0, .9), rgba(97, 218, 251, .7)"}},"body":"<p>Lâ€™Ã©quipe de React a implÃ©mentÃ© une fonctionnalitÃ© appelÃ©e\n<a href=\"http://facebook.github.io/react/docs/test-utils.html#shallow-rendering\">shallow rendering</a>\n(rendu peu profond),\nqui permet de rendre un composant avec un seul niveau de profondeur de rendu.</p>\n<p>Cela permet du coup de vÃ©rifier ce que le rendu retourne sans avoir Ã  se\nsoucier du comportement des composants enfants, qui ne sont pas instanciÃ©s ni\nrendus. Cela ne nÃ©cessite pas de DOM.</p>\n<p>IntÃ©ressant, nâ€™est-ce pas ? Et dâ€™ailleurs, le <em>shallow rendering</em> est\nactuellement\n<a href=\"https://discuss.reactjs.org/t/whats-the-prefered-way-to-test-react-js-components/26\">la mÃ©thode recommandÃ©e pour tester vos composants React</a>.</p>\n<p>Comme vous pourrez le voir dans un article listÃ© Ã  la fin de celui-ci,\nle code permettant de tester des composants avec cette technique nâ€™est pas\nforcÃ©ment trÃ¨s concis, contrairement Ã  ce quâ€™on pourrait attendre.</p>\n<p>Heureusement, <a href=\"https://github.com/vvo\">quelquâ€™un</a> a codÃ© un truc plutÃ´t cool :\n<a href=\"https://github.com/algolia/react-element-to-jsx-string\">react-element-to-jsx-string</a>.\nComme le nom lâ€™indique, cette librairie permet de rendre un composant React en\ntant que chaÃ®ne JSX.</p>\n<p>Câ€™est maintenant les choses deviennent intÃ©ressantesÂ :\navec ces concepts en tÃªte (le shallow render et le rendu de composant en strings\nJSX), on peut facilement ajouter de simple tests unitaires sur ses composants.</p>\n<p><em>Il y a dâ€™autres techniques pour tester des composants React, et la plupart\nimplique le DOM. Vous devrez donc Ã©xecuter vos tests dans un navigateur (ou\nen utilisant jsdom)Â : vos tests seront plus lents que la technique qui va suivre\n(qui pour le coup est plus du vrai test unitaire, dans le sens oÃ¹ vous utilisez\nmoins de code et ne nÃ©cessitez pas un gros environnement).</em></p>\n<h2 id=\"tester-facilement-des-composants-react-sans-dom\"><a class=\"markdownIt-Anchor\" href=\"#tester-facilement-des-composants-react-sans-dom\">#</a> Tester facilement des composants React (sans DOM)</h2>\n<p>On va partir avec ce simple composantÂ :</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// web_modules/Picture/index.js</span>\n\n<span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>\n<span class=\"hljs-keyword\">import</span> { PropTypes } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>\n\nconst Component = ({\n  img,\n  title,\n  Loader,\n  Title,\n}) =&gt; (\n  &lt;div&gt;\n    {\n      (!img || !img.src) &amp;&amp; Loader &amp;&amp;\n      &lt;Loader /&gt;\n    }\n    {\n      img &amp;&amp; img.src &amp;&amp;\n      &lt;img src={ img.src } alt={ img.alt }/&gt;\n    }\n    {\n      title &amp;&amp; Title &amp;&amp;\n      &lt;Title text={ title } /&gt;\n    }\n  &lt;/div&gt;\n)\n\nComponent.propTypes = {\n  img: PropTypes.object,\n  title: PropTypes.string,\n  Loader: PropTypes.func.isRequired,\n  Title: PropTypes.func.isRequired,\n}\n\nComponent.displayName = <span class=\"hljs-string\">\"Picture\"</span>\n\nexport default Component</code></pre>\n<p>Ce composant affiche une image avec un composant pour le titre.\nSi les donnÃ©es de lâ€™image ne sont pas prÃªtes, on peut afficher un composant pour\nindiquer le chargement.</p>\n<p>Ã‰crivons maintenant un petit test. Pour notre exemple, on va utiliser\n<a href=\"https://medium.com/javascript-scene/why-i-use-tape-instead-of-mocha-so-should-you-6aa105d8eaf4\">tape</a>\ncouplÃ© avec <a href=\"https://github.com/atabel/tape-jsx-equals\">tape-jsx-equals</a>,\nmais vous nâ€™aurez pas de mal Ã  trouver un paquet Ã \n<a href=\"https://www.npmjs.com/search?q=expect+jsx\">votre sauce sur npm</a>.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">// web_modules/Picture/__tests__/index.js</span>\n\n<span class=\"hljs-keyword\">import</span> tape <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"tape\"</span>\n<span class=\"hljs-keyword\">import</span> addAssertions <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"extend-tape\"</span>\n<span class=\"hljs-keyword\">import</span> jsxEquals <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"tape-jsx-equals\"</span>\nconst test = addAssertions(tape, { jsxEquals })\n\n<span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>\n<span class=\"hljs-keyword\">import</span> { createRenderer } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react-addons-test-utils\"</span>\n\n<span class=\"hljs-keyword\">import</span> Picture <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"..\"</span>\n\n// fixtures (empty and stateless react components)\nconst Loader = () =&gt; {}\nconst Title = () =&gt; {}\n\ntest(<span class=\"hljs-string\">\"PageContainer is properly rendered\"</span>, (t) =&gt; {\n  const renderer = createRenderer()\n\n  renderer.render(\n    &lt;Picture\n      Loader={ Loader }\n      Title={ Title }\n    /&gt;\n  )\n  t.jsxEquals(\n    renderer.getRenderOutput(),\n    &lt;div&gt;\n      &lt;Loader /&gt;\n    &lt;/div&gt;,\n    <span class=\"hljs-string\">\"can render a Loader component if no image data are passed\"</span>\n  )\n\n  renderer.render(\n    &lt;Picture\n      Loader={ Loader }\n      Title={ Title }\n      img={ {\n        src: <span class=\"hljs-string\">\"SRC\"</span>,\n        alt: <span class=\"hljs-string\">\"ALT\"</span>,\n      } }\n    /&gt;\n  )\n  t.jsxEquals(\n    renderer.getRenderOutput(),\n    &lt;div&gt;\n      &lt;img src=<span class=\"hljs-string\">\"SRC\"</span> alt=<span class=\"hljs-string\">\"ALT\"</span> /&gt;\n    &lt;/div&gt;,\n    <span class=\"hljs-string\">\"should render an image if data are passed\"</span>\n  )\n\n  renderer.render(\n    &lt;Picture\n      Loader={ Loader }\n      Title={ Title }\n      img={ {\n        src: <span class=\"hljs-string\">\"SRC\"</span>,\n        alt: <span class=\"hljs-string\">\"ALT\"</span>,\n      } }\n      title={ <span class=\"hljs-string\">\"TITLE\"</span> }\n    /&gt;\n  )\n  t.jsxEquals(\n    renderer.getRenderOutput(),\n    &lt;div&gt;\n      &lt;img src=<span class=\"hljs-string\">\"SRC\"</span> alt=<span class=\"hljs-string\">\"ALT\"</span> /&gt;\n      &lt;Title text=<span class=\"hljs-string\">\"TITLE\"</span> /&gt;\n    &lt;/div&gt;,\n    <span class=\"hljs-string\">\"can render a Title if data are passed\"</span>\n  )\n\n  t.end()\n})</code></pre>\n<p>Ces tests sont une couverture minimale pour vous assurer que vous ne cassez rien\nlorsque vous travaillez sur votre composant.</p>\n<p>Comme vous pouvez le constater, les tests sont assez simples Ã  Ã©crire et vont\ndroit au but.\n<strong>Ce qui est intÃ©ressant ici, câ€™est que nous ne comparons pas Ã  lâ€™aide de\nsimples chaÃ®nes. Nous utilisons directement des composants React.</strong></p>\n<p>Vous pouvez tranquillement exÃ©cuter lâ€™exemple complet et le rÃ©cupÃ©rer depuis le\nrepositoryÂ :</p>\n<p><a href=\"https://github.com/MoOx/react-component-unit-testing-example\">github.com/MoOx/react-component-unit-testing-example</a></p>\n<p>Cet exemple contient les commandes et dÃ©pendances\n(dÃ©finies dans le <code>package.json</code>)\ndont vous aurez besoin.</p>\n<h1 id=\"et-comment-tester-les-v-nements-comme-onclick\"><a class=\"markdownIt-Anchor\" href=\"#et-comment-tester-les-v-nements-comme-onclick\">#</a> Et comment tester les Ã©vÃ¨nements comme <code>onClick</code> ?</h1>\n<p>Vous nâ€™avez pas Ã  reproduire le clic complÃ¨tement.</p>\n<p><strong>Vos tests nâ€™ont pas besoin de vÃ©rifier que la prop <code>onClick</code> va bien Ãªtre\nexÃ©cutÃ©e lorsque vous cliquerez sur un Ã©lÃ©ment du DOM.</strong>\n<em>React couvre probablement cela dans sa suite de tests.</em></p>\n<p>Ce que vous avez besoin de tester, câ€™est que la valeur que vous passez au\n<code>onClick</code> fait bien ce que vous voulez.\nEn gros, si vous avez un bout de code qui ressemble Ã \n<code>onClick={ yourCallback }</code>, vous nâ€™avez tout simplement quâ€™Ã  appeler directement\n<code>yourCallback()</code> dans vos tests juste avant votre comparaison.\nCâ€™est bien assez !</p>\n<p>Si vous voulez aller un peu plus loin, vous pouvez continuer par lireÂ :</p>\n<ul>\n<li><a href=\"http://simonsmith.io/unit-testing-react-components-without-a-dom/\"><em>Unit testing React components without a DOM</em></a>,\npar Simon Smith, qui couvre le mÃªme sujet, sans la simplicitÃ© de la comparaison\nJSX,</li>\n<li><a href=\"https://blog.algolia.com/how-we-unit-test-react-components-using-expect-jsx/\"><em>How we unit test React components using expect-jsx</em></a>\nsur le blog dâ€™Algolia, qui explique pourquoi ils ont choisi et crÃ©Ã© les outils\npour cette approche.</li>\n</ul>\n<p>Avec ces exemples, nous espÃ©rons vraiment que vous nâ€™aurez plus peur de tester\nvotre code et que vous nâ€™hÃ©siterez plus Ã  couvrir tous vos composants React de\ntests ğŸ˜.</p>\n","rawBody":"\nL'Ã©quipe de React a implÃ©mentÃ© une fonctionnalitÃ© appelÃ©e\n[shallow rendering](http://facebook.github.io/react/docs/test-utils.html#shallow-rendering)\n(rendu peu profond),\nqui permet de rendre un composant avec un seul niveau de profondeur de rendu.\n\nCela permet du coup de vÃ©rifier ce que le rendu retourne sans avoir Ã  se\nsoucier du comportement des composants enfants, qui ne sont pas instanciÃ©s ni\nrendus. Cela ne nÃ©cessite pas de DOM.\n\nIntÃ©ressant, n'est-ce pas ? Et d'ailleurs, le _shallow rendering_ est\nactuellement\n[la mÃ©thode recommandÃ©e pour tester vos composants React](https://discuss.reactjs.org/t/whats-the-prefered-way-to-test-react-js-components/26).\n\nComme vous pourrez le voir dans un article listÃ© Ã  la fin de celui-ci,\nle code permettant de tester des composants avec cette technique n'est pas\nforcÃ©ment trÃ¨s concis, contrairement Ã  ce qu'on pourrait attendre.\n\nHeureusement, [quelqu'un](https://github.com/vvo) a codÃ© un truc plutÃ´t cool :\n[react-element-to-jsx-string](https://github.com/algolia/react-element-to-jsx-string).\nComme le nom l'indique, cette librairie permet de rendre un composant React en\ntant que chaÃ®ne JSX.\n\nC'est maintenant les choses deviennent intÃ©ressantesÂ :\navec ces concepts en tÃªte (le shallow render et le rendu de composant en strings\nJSX), on peut facilement ajouter de simple tests unitaires sur ses composants.\n\n_Il y a d'autres techniques pour tester des composants React, et la plupart\nimplique le DOM. Vous devrez donc Ã©xecuter vos tests dans un navigateur (ou\nen utilisant jsdom)Â : vos tests seront plus lents que la technique qui va suivre\n(qui pour le coup est plus du vrai test unitaire, dans le sens oÃ¹ vous utilisez\nmoins de code et ne nÃ©cessitez pas un gros environnement)._\n\n## Tester facilement des composants React (sans DOM)\n\nOn va partir avec ce simple composantÂ :\n\n```js\n// web_modules/Picture/index.js\n\nimport React from \"react\"\nimport { PropTypes } from \"react\"\n\nconst Component = ({\n  img,\n  title,\n  Loader,\n  Title,\n}) => (\n  <div>\n    {\n      (!img || !img.src) && Loader &&\n      <Loader />\n    }\n    {\n      img && img.src &&\n      <img src={ img.src } alt={ img.alt }/>\n    }\n    {\n      title && Title &&\n      <Title text={ title } />\n    }\n  </div>\n)\n\nComponent.propTypes = {\n  img: PropTypes.object,\n  title: PropTypes.string,\n  Loader: PropTypes.func.isRequired,\n  Title: PropTypes.func.isRequired,\n}\n\nComponent.displayName = \"Picture\"\n\nexport default Component\n```\n\nCe composant affiche une image avec un composant pour le titre.\nSi les donnÃ©es de l'image ne sont pas prÃªtes, on peut afficher un composant pour\nindiquer le chargement.\n\nÃ‰crivons maintenant un petit test. Pour notre exemple, on va utiliser\n[tape](https://medium.com/javascript-scene/why-i-use-tape-instead-of-mocha-so-should-you-6aa105d8eaf4)\ncouplÃ© avec [tape-jsx-equals](https://github.com/atabel/tape-jsx-equals),\nmais vous n'aurez pas de mal Ã  trouver un paquet Ã \n[votre sauce sur npm](https://www.npmjs.com/search?q=expect+jsx).\n\n```js\n// web_modules/Picture/__tests__/index.js\n\nimport tape from \"tape\"\nimport addAssertions from \"extend-tape\"\nimport jsxEquals from \"tape-jsx-equals\"\nconst test = addAssertions(tape, { jsxEquals })\n\nimport React from \"react\"\nimport { createRenderer } from \"react-addons-test-utils\"\n\nimport Picture from \"..\"\n\n// fixtures (empty and stateless react components)\nconst Loader = () => {}\nconst Title = () => {}\n\ntest(\"PageContainer is properly rendered\", (t) => {\n  const renderer = createRenderer()\n\n  renderer.render(\n    <Picture\n      Loader={ Loader }\n      Title={ Title }\n    />\n  )\n  t.jsxEquals(\n    renderer.getRenderOutput(),\n    <div>\n      <Loader />\n    </div>,\n    \"can render a Loader component if no image data are passed\"\n  )\n\n  renderer.render(\n    <Picture\n      Loader={ Loader }\n      Title={ Title }\n      img={ {\n        src: \"SRC\",\n        alt: \"ALT\",\n      } }\n    />\n  )\n  t.jsxEquals(\n    renderer.getRenderOutput(),\n    <div>\n      <img src=\"SRC\" alt=\"ALT\" />\n    </div>,\n    \"should render an image if data are passed\"\n  )\n\n  renderer.render(\n    <Picture\n      Loader={ Loader }\n      Title={ Title }\n      img={ {\n        src: \"SRC\",\n        alt: \"ALT\",\n      } }\n      title={ \"TITLE\" }\n    />\n  )\n  t.jsxEquals(\n    renderer.getRenderOutput(),\n    <div>\n      <img src=\"SRC\" alt=\"ALT\" />\n      <Title text=\"TITLE\" />\n    </div>,\n    \"can render a Title if data are passed\"\n  )\n\n  t.end()\n})\n```\n\nCes tests sont une couverture minimale pour vous assurer que vous ne cassez rien\nlorsque vous travaillez sur votre composant.\n\nComme vous pouvez le constater, les tests sont assez simples Ã  Ã©crire et vont\ndroit au but.\n**Ce qui est intÃ©ressant ici, c'est que nous ne comparons pas Ã  l'aide de\nsimples chaÃ®nes. Nous utilisons directement des composants React.**\n\nVous pouvez tranquillement exÃ©cuter l'exemple complet et le rÃ©cupÃ©rer depuis le\nrepositoryÂ :\n\n[github.com/MoOx/react-component-unit-testing-example](https://github.com/MoOx/react-component-unit-testing-example)\n\nCet exemple contient les commandes et dÃ©pendances\n(dÃ©finies dans le `package.json`)\ndont vous aurez besoin.\n\n# Et comment tester les Ã©vÃ¨nements comme `onClick` ?\n\nVous n'avez pas Ã  reproduire le clic complÃ¨tement.\n\n**Vos tests n'ont pas besoin de vÃ©rifier que la prop `onClick` va bien Ãªtre\nexÃ©cutÃ©e lorsque vous cliquerez sur un Ã©lÃ©ment du DOM.**\n_React couvre probablement cela dans sa suite de tests._\n\nCe que vous avez besoin de tester, c'est que la valeur que vous passez au\n`onClick` fait bien ce que vous voulez.\nEn gros, si vous avez un bout de code qui ressemble Ã \n`onClick={ yourCallback }`, vous n'avez tout simplement qu'Ã  appeler directement\n`yourCallback()` dans vos tests juste avant votre comparaison.\nC'est bien assez !\n\nSi vous voulez aller un peu plus loin, vous pouvez continuer par lireÂ :\n- [_Unit testing React components without a DOM_](http://simonsmith.io/unit-testing-react-components-without-a-dom/),\npar Simon Smith, qui couvre le mÃªme sujet, sans la simplicitÃ© de la comparaison\nJSX,\n- [_How we unit test React components using expect-jsx_](https://blog.algolia.com/how-we-unit-test-react-components-using-expect-jsx/)\nsur le blog d'Algolia, qui explique pourquoi ils ont choisi et crÃ©Ã© les outils\npour cette approche.\n\nAvec ces exemples, nous espÃ©rons vraiment que vous n'aurez plus peur de tester\nvotre code et que vous n'hÃ©siterez plus Ã  couvrir tous vos composants React de\ntests ğŸ˜.\n","raw":"---\ndate: \"2015-11-24\"\ntitle: Tester unitairement des composants React\ntags:\n  - js\n  - react\n  - tests\nauthors:\n  - MoOx\nheader:\n  image: https://farm6.staticflickr.com/5159/7112879347_9e0da289ca_z.jpg\n  credit: https://www.flickr.com/photos/dvids/7112879347\n  linearGradient: 160deg, rgba(0,0,0, .9), rgba(97, 218, 251, .7)\n---\n\nL'Ã©quipe de React a implÃ©mentÃ© une fonctionnalitÃ© appelÃ©e\n[shallow rendering](http://facebook.github.io/react/docs/test-utils.html#shallow-rendering)\n(rendu peu profond),\nqui permet de rendre un composant avec un seul niveau de profondeur de rendu.\n\nCela permet du coup de vÃ©rifier ce que le rendu retourne sans avoir Ã  se\nsoucier du comportement des composants enfants, qui ne sont pas instanciÃ©s ni\nrendus. Cela ne nÃ©cessite pas de DOM.\n\nIntÃ©ressant, n'est-ce pas ? Et d'ailleurs, le _shallow rendering_ est\nactuellement\n[la mÃ©thode recommandÃ©e pour tester vos composants React](https://discuss.reactjs.org/t/whats-the-prefered-way-to-test-react-js-components/26).\n\nComme vous pourrez le voir dans un article listÃ© Ã  la fin de celui-ci,\nle code permettant de tester des composants avec cette technique n'est pas\nforcÃ©ment trÃ¨s concis, contrairement Ã  ce qu'on pourrait attendre.\n\nHeureusement, [quelqu'un](https://github.com/vvo) a codÃ© un truc plutÃ´t cool :\n[react-element-to-jsx-string](https://github.com/algolia/react-element-to-jsx-string).\nComme le nom l'indique, cette librairie permet de rendre un composant React en\ntant que chaÃ®ne JSX.\n\nC'est maintenant les choses deviennent intÃ©ressantesÂ :\navec ces concepts en tÃªte (le shallow render et le rendu de composant en strings\nJSX), on peut facilement ajouter de simple tests unitaires sur ses composants.\n\n_Il y a d'autres techniques pour tester des composants React, et la plupart\nimplique le DOM. Vous devrez donc Ã©xecuter vos tests dans un navigateur (ou\nen utilisant jsdom)Â : vos tests seront plus lents que la technique qui va suivre\n(qui pour le coup est plus du vrai test unitaire, dans le sens oÃ¹ vous utilisez\nmoins de code et ne nÃ©cessitez pas un gros environnement)._\n\n## Tester facilement des composants React (sans DOM)\n\nOn va partir avec ce simple composantÂ :\n\n```js\n// web_modules/Picture/index.js\n\nimport React from \"react\"\nimport { PropTypes } from \"react\"\n\nconst Component = ({\n  img,\n  title,\n  Loader,\n  Title,\n}) => (\n  <div>\n    {\n      (!img || !img.src) && Loader &&\n      <Loader />\n    }\n    {\n      img && img.src &&\n      <img src={ img.src } alt={ img.alt }/>\n    }\n    {\n      title && Title &&\n      <Title text={ title } />\n    }\n  </div>\n)\n\nComponent.propTypes = {\n  img: PropTypes.object,\n  title: PropTypes.string,\n  Loader: PropTypes.func.isRequired,\n  Title: PropTypes.func.isRequired,\n}\n\nComponent.displayName = \"Picture\"\n\nexport default Component\n```\n\nCe composant affiche une image avec un composant pour le titre.\nSi les donnÃ©es de l'image ne sont pas prÃªtes, on peut afficher un composant pour\nindiquer le chargement.\n\nÃ‰crivons maintenant un petit test. Pour notre exemple, on va utiliser\n[tape](https://medium.com/javascript-scene/why-i-use-tape-instead-of-mocha-so-should-you-6aa105d8eaf4)\ncouplÃ© avec [tape-jsx-equals](https://github.com/atabel/tape-jsx-equals),\nmais vous n'aurez pas de mal Ã  trouver un paquet Ã \n[votre sauce sur npm](https://www.npmjs.com/search?q=expect+jsx).\n\n```js\n// web_modules/Picture/__tests__/index.js\n\nimport tape from \"tape\"\nimport addAssertions from \"extend-tape\"\nimport jsxEquals from \"tape-jsx-equals\"\nconst test = addAssertions(tape, { jsxEquals })\n\nimport React from \"react\"\nimport { createRenderer } from \"react-addons-test-utils\"\n\nimport Picture from \"..\"\n\n// fixtures (empty and stateless react components)\nconst Loader = () => {}\nconst Title = () => {}\n\ntest(\"PageContainer is properly rendered\", (t) => {\n  const renderer = createRenderer()\n\n  renderer.render(\n    <Picture\n      Loader={ Loader }\n      Title={ Title }\n    />\n  )\n  t.jsxEquals(\n    renderer.getRenderOutput(),\n    <div>\n      <Loader />\n    </div>,\n    \"can render a Loader component if no image data are passed\"\n  )\n\n  renderer.render(\n    <Picture\n      Loader={ Loader }\n      Title={ Title }\n      img={ {\n        src: \"SRC\",\n        alt: \"ALT\",\n      } }\n    />\n  )\n  t.jsxEquals(\n    renderer.getRenderOutput(),\n    <div>\n      <img src=\"SRC\" alt=\"ALT\" />\n    </div>,\n    \"should render an image if data are passed\"\n  )\n\n  renderer.render(\n    <Picture\n      Loader={ Loader }\n      Title={ Title }\n      img={ {\n        src: \"SRC\",\n        alt: \"ALT\",\n      } }\n      title={ \"TITLE\" }\n    />\n  )\n  t.jsxEquals(\n    renderer.getRenderOutput(),\n    <div>\n      <img src=\"SRC\" alt=\"ALT\" />\n      <Title text=\"TITLE\" />\n    </div>,\n    \"can render a Title if data are passed\"\n  )\n\n  t.end()\n})\n```\n\nCes tests sont une couverture minimale pour vous assurer que vous ne cassez rien\nlorsque vous travaillez sur votre composant.\n\nComme vous pouvez le constater, les tests sont assez simples Ã  Ã©crire et vont\ndroit au but.\n**Ce qui est intÃ©ressant ici, c'est que nous ne comparons pas Ã  l'aide de\nsimples chaÃ®nes. Nous utilisons directement des composants React.**\n\nVous pouvez tranquillement exÃ©cuter l'exemple complet et le rÃ©cupÃ©rer depuis le\nrepositoryÂ :\n\n[github.com/MoOx/react-component-unit-testing-example](https://github.com/MoOx/react-component-unit-testing-example)\n\nCet exemple contient les commandes et dÃ©pendances\n(dÃ©finies dans le `package.json`)\ndont vous aurez besoin.\n\n# Et comment tester les Ã©vÃ¨nements comme `onClick` ?\n\nVous n'avez pas Ã  reproduire le clic complÃ¨tement.\n\n**Vos tests n'ont pas besoin de vÃ©rifier que la prop `onClick` va bien Ãªtre\nexÃ©cutÃ©e lorsque vous cliquerez sur un Ã©lÃ©ment du DOM.**\n_React couvre probablement cela dans sa suite de tests._\n\nCe que vous avez besoin de tester, c'est que la valeur que vous passez au\n`onClick` fait bien ce que vous voulez.\nEn gros, si vous avez un bout de code qui ressemble Ã \n`onClick={ yourCallback }`, vous n'avez tout simplement qu'Ã  appeler directement\n`yourCallback()` dans vos tests juste avant votre comparaison.\nC'est bien assez !\n\nSi vous voulez aller un peu plus loin, vous pouvez continuer par lireÂ :\n- [_Unit testing React components without a DOM_](http://simonsmith.io/unit-testing-react-components-without-a-dom/),\npar Simon Smith, qui couvre le mÃªme sujet, sans la simplicitÃ© de la comparaison\nJSX,\n- [_How we unit test React components using expect-jsx_](https://blog.algolia.com/how-we-unit-test-react-components-using-expect-jsx/)\nsur le blog d'Algolia, qui explique pourquoi ils ont choisi et crÃ©Ã© les outils\npour cette approche.\n\nAvec ces exemples, nous espÃ©rons vraiment que vous n'aurez plus peur de tester\nvotre code et que vous n'hÃ©siterez plus Ã  couvrir tous vos composants React de\ntests ğŸ˜.\n","__filename":"fr/articles/js/react/test-unitaires.md","__url":"/fr/articles/js/react/test-unitaires/"}