{"head":{"layout":"Post","comments":true,"date":"2015-02-23","title":"Quelques retours sur React et le rendu serveur","tags":["javascript","react"],"authors":["lionelB"]},"body":"<p>On entend souvent parler d’applications JavaScript isomorphiques, et même si le\nnom ne <a href=\"https://news.ycombinator.com/item?id=8237449\">fait</a> <a href=\"https://twitter.com/wycats/status/566857009836724224\">pas</a>\n<a href=\"https://medium.com/the-thinkmill/making-the-case-for-progressive-javascript-a98dfa82b9d7\">l’unanimité</a>,\nce qu’il y a derrière, le concept de <em>server side rendered JavaScript</em> est en\npasse de devenir  un sujet plutôt tendance pour 2015 grâce à la monté en puissance\nde <a href=\"http://facebook.github.io/react/\">Reactjs</a>.  Faire du rendu d’application\nJavaScript coté serveur permet de réconcilier enfin le développeur de\n<em>Single Page App</em> (SPA) avec l’amélioration progressive, l’accessibilité et le\nSEO ; quoique Google comme les lecteurs d’écran ont plutôt bien évolué sur\nce point. L’autre avantage non négligeable à mon sens, est qu’on améliore les\nperformances perçues par rapport\nà une SPA classique puisque :</p>\n<ul>\n<li>On supprime une requête <em>ajax</em> au démarrage pour récupérer le contenu\ninitial.</li>\n<li>On améliore la vitesse de rendu initial de page.</li>\n<li>On bénéficie de la fluidité de navigation d’une SPA.</li>\n</ul>\n<p>Pour plus d’info sur les avantages, il y a <a href=\"http://tech.m6web.fr/isomorphic-single-page-app-parfaite-react-flux/\">cet article</a> sur le blog de M6Tech.</p>\n<p>Afin de me familiariser avec React et son écosystème, rien de mieux que mettre\nles mains dedans ! C’est un peu pour toutes ces raisons que j’ai décidé de\nl’utiliser pour mon site web (un site statique).</p>\n<p><strong>Inutile et donc totalement justifié pour le développeur que je suis</strong>.\nUne des premières briques que j’ai mises en place a été le routeur.</p>\n<p>##react-router\nPour une fois dans la communauté JavaScript, il y a une bibliothèque de référence\net c’est celle là : <a href=\"https://github.com/rackt/react-router\">react-router</a>.\nLe routeur est fortement inspiré par celui d’Ember au sens où les URL et leurs routes\nsont au cœur du dispositif. Le routeur se présente sous forme de composant React\net ça donne ça.</p>\n<pre><code class=\"language-jsx\"><span class=\"hljs-comment\">//routes.js</span>\n\n<span class=\"hljs-built_in\">var</span> React = <span class=\"hljs-keyword\">require</span>(<span class=\"hljs-string\">\"react\"</span>);\n<span class=\"hljs-built_in\">var</span> Router = <span class=\"hljs-keyword\">require</span>(<span class=\"hljs-string\">\"react-router\"</span>);\n\n<span class=\"hljs-built_in\">var</span> Route = Router<span class=\"hljs-built_in\">.</span>Route;\n<span class=\"hljs-built_in\">var</span> DefaultRoute = Router<span class=\"hljs-built_in\">.</span>DefaultRoute;\n<span class=\"hljs-built_in\">var</span> NotFoundRoute = Router<span class=\"hljs-built_in\">.</span>NotFoundRoute;\n\n<span class=\"hljs-built_in\">var</span> App = <span class=\"hljs-keyword\">require</span>(<span class=\"hljs-string\">\"./app\"</span>);\n<span class=\"hljs-built_in\">var</span> Home = <span class=\"hljs-keyword\">require</span>(<span class=\"hljs-string\">\"./home/homePage\"</span>);\n<span class=\"hljs-built_in\">var</span> Project = <span class=\"hljs-keyword\">require</span>(<span class=\"hljs-string\">\"./project/projectPage\"</span>);\n<span class=\"hljs-built_in\">var</span> NotFound = <span class=\"hljs-keyword\">require</span>(<span class=\"hljs-string\">\"./notFound\"</span>);\n\n<span class=\"hljs-built_in\">var</span> routes = (\n  &lt;Route path=<span class=\"hljs-string\">\"/\"</span> handler={App}&gt;\n    &lt;DefaultRoute name=<span class=\"hljs-string\">\"index\"</span> handler={Home} /&gt;\n    &lt;Route name=<span class=\"hljs-string\">\"project\"</span> path=<span class=\"hljs-string\">\"/projects/:url\"</span> handler={Project} /&gt;\n    &lt;NotFoundRoute name=<span class=\"hljs-string\">\"404\"</span> handler={NotFound} /&gt;\n  &lt;/Route&gt;\n);\n\nmodule<span class=\"hljs-built_in\">.</span>exports = routes;</code></pre>\n<p>À mon sens, l’aspect déclaratif apporte de la clarté et améliore la compréhension\ndu système. On voit rapidement quel composant est utilisé en fonction de l’URL.\nL’autre avantage du déclaratif, c’est qu’il permet de manière assez simple,\nd’imbriquer les routes en imbriquant les nœuds <code>&lt;Route&gt;</code>.</p>\n<p>En plus des composants, on a aussi à disposition des <em>mixins</em> pour naviguer\nprogrammatiquement ou accéder aux infos du routeur (chemin, paramètres, …)</p>\n<p>Et le gros plus de cette bibliothèque : elle peut aussi s’utiliser coté serveur,\npour la génération des vues et éviter ainsi de dupliquer du code puisqu’on va\npouvoir carrément utiliser tel quel le fichier précédent. Plutôt cool !\nVoici un exemple de <em>middleware</em> pour faire marcher ça dans Express :</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> React = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"react\"</span>);\n<span class=\"hljs-keyword\">var</span> Router = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"react-router\"</span>);\n\n<span class=\"hljs-comment\">// notre fichier routes.js</span>\n<span class=\"hljs-keyword\">var</span> routes = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"./src/routes\"</span>);\n<span class=\"hljs-comment\">// notre template de page html</span>\n<span class=\"hljs-keyword\">var</span> Html = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"./src/html\"</span>);\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">reactView</span>(<span class=\"hljs-params\">req, res, next</span>) </span>{\n  Router.run(routes, req.url, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">Handler, state</span>) </span>{\n    <span class=\"hljs-comment\">// on récupère les données pour cette vue en fonction de la requête.</span>\n    <span class=\"hljs-keyword\">var</span> data = getViewData(req);\n\n    <span class=\"hljs-comment\">// on génère la soupe au tag avec nos données dedans</span>\n    <span class=\"hljs-keyword\">var</span> markup = React.renderToString(React.createElement(Handler), data);\n\n    <span class=\"hljs-comment\">// on utilise React comme moteur de template</span>\n    <span class=\"hljs-keyword\">var</span> HtmlElement = React.createElement(Html, {markup: markup});\n    res.send(<span class=\"hljs-string\">\"&lt;!DOCTYPE html&gt;\"</span> +  React.renderToStaticMarkup(HtmlElement));\n  });\n}</code></pre>\n<p>Et voici le composant <code>Html.jsx</code> que l’on utilise comme <em>template</em> pour notre page principale.</p>\n<pre><code class=\"language-jsx\">var React = require('react');\n\nvar Html = React.createClass({\n  render: function() {\n    return (\n      <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">html</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">head</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">meta</span> <span class=\"hljs-attribute\">charSet</span>=<span class=\"hljs-value\">\"utf-8\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">meta</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">title</span>&gt;</span>Mon site perso<span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">title</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-attribute\">src</span>=<span class=\"hljs-value\">\"/js/app.js\"</span> /&gt;</span><span class=\"handlebars\"><span class=\"xml\">\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">head</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">body</span>&gt;</span>\n          <span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">div</span> <span class=\"hljs-attribute\">id</span>=<span class=\"hljs-value\">\"react-app\"</span> <span class=\"hljs-attribute\">dangerouslySetInnerHTML</span>=</span></span><span class=\"hljs-expression\">{{__<span class=\"hljs-variable\">html</span>: <span class=\"hljs-variable\">this.props.markup</span>}}</span><span class=\"xml\"><span class=\"hljs-tag\"> /&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">body</span>&gt;</span>\n      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-title\">html</span>&gt;</span>\n    );\n  }\n\n});\n\nmodule.exports = Html;</span></span></code></pre>\n<p>Une fois que le code HTML a été généré via<code>React.renderToString(React.createElement(Handler), data);</code>,\non pourrait utiliser n’importe quel moteur de template (lodash.template, handlebars, ejs, jade, PHP…)\npour générer le HTML de la page à renvoyer. Dans un souci de rationalisation des outils,\nj’ai préféré utiliser React.</p>\n<p>Vous avez dû vous apercevoir qu’on utilise 2 méthodes différentes pour générer\ndu HTML avec React :</p>\n<ul>\n<li><code>React.renderToString(React.createElement(Handler), data);</code></li>\n<li><code>React.renderToStaticMarkup(React.createElement(Handler), data);</code></li>\n</ul>\n<p>La différence entre les deux méthodes est simple. Dans la première, React annote\nles nœuds HTML avec des <code>data-reactid</code> dans le but de pouvoir ensuite reprendre\nla main lorsque votre l’application s’exécutera dans le navigateur. De cette manière,\nReact sait que vous l’initialisez avec un contenu généré depuis le serveur.\nEt si il détecte une différence entre le code existant et celui qu’il génère,\nvous aurez droit à un <a href=\"https://github.com/facebook/react/blob/2aeb8a2a6beb00617a4217f7f8284924fa2ad819/src/browser/ui/__tests__/ReactRenderDocument-test.js#L205-L215\">petit warning</a>.\nLa deuxième méthode permet de générer du code HTML sans annotations,\ncomme n’importe quel moteur de <em>template</em>.</p>\n<p>Les plus attentifs auront remarqué qu’on passe les données initiales lors de\nla création de l’application via des <em>props</em> React. Quid de l’utilisation\nde flux dans tout ça ?</p>\n<h2 id=\"flux-et-le-rendu-serveur\"><a class=\"markdownIt-Anchor\" href=\"#flux-et-le-rendu-serveur\">#</a> Flux et le rendu serveur</h2>\n<p>Avec <a href=\"http://facebook.github.io/flux/\">Flux</a>, ce sont les stores qui maintiennent\nl’état de notre application. Si l’on ne veut pas afficher notre application\nsans aucune données, nous allons devoir préalablement peupler nos stores\navant d’appeler <code>React.renderToString()</code>.</p>\n<p>Là où ça se corse un peu, c’est qu’il va falloir remplir nos stores avant de démarrer\nnotre application sous peine de voir le message d’alerte dont je parlais plus haut.\nLe plus simple alors est de passer ces données au moteur de template,\nen plus du markup (par exemple sous la forme d’un nœud <code>&lt;script type=&quot;application/json&quot;&gt;JSON DATA&lt;/script&gt;</code>.\nIl ne reste plus qu’a récupérer ces données avant d’appeler <code>React.render( Application, document.getElementById(&quot;react-app&quot;))</code></p>\n<p>Par exemple :</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-built_in\">document</span>.addEventListener(<span class=\"hljs-string\">\"DOMContentLoaded\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">event</span>) </span>{\n  <span class=\"hljs-comment\">// getData() va récuperer et parser le contenu du tag script</span>\n  <span class=\"hljs-comment\">// qui contient nos données</span>\n  <span class=\"hljs-keyword\">var</span> storeData= getData();\n\n  <span class=\"hljs-comment\">// on déclenche une actions</span>\n  actions.init( storeData);\n\n  <span class=\"hljs-comment\">// on lance le rendu</span>\n  React.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">App</span> /&gt;</span>, document.getElementById(\"react-app\"));\n});</span></code></pre>\n<h2 id=\"le-mot-de-la-fin\"><a class=\"markdownIt-Anchor\" href=\"#le-mot-de-la-fin\">#</a> Le mot de la fin</h2>\n<p>Penser son application React pour qu’elle puisse être rendue coté serveur\nintroduit de nouvelles problématiques, notamment avec l’ajout du <em>pattern</em> Flux.\nEn fonction des pages que l’on souhaite afficher, on devra initialiser différents <em>stores</em>.\nÀ nous de déterminer, en fonction de l’URL et du composant à afficher,\nlequel initialiser, et cela, que l’on soit sur le client ou le serveur.\nDe la même manière, il faudra être capable de charger nos données, indépendamment\nde l’environnement d’exécution (coucou XHR).</p>\n<p>Un début de réponse se trouve dans les exemples fournis avec react-router.\nL’idée est de passer par une propriété <code>statics</code> lors de la création des composants React\nqui seront associés à une <code>&lt;Route/&gt;</code>.</p>\n<pre><code class=\"language-jsx\"><span class=\"hljs-keyword\">var</span> ProjectPage = React.createClass({\n  statics: {\n    fetchData: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(params)</span></span>{\n      <span class=\"hljs-keyword\">return</span> api.getPageData(params.url)\n        .then( actions.initProject)\n        .<span class=\"hljs-keyword\">catch</span>( actions.loadProjectError);\n    }\n  }\n ...\n });</code></pre>\n<p>Dans ce bloc <code>statics</code>, on définit une fonction qui servira à récupérer les données\npour ce composant mais on pourrait très bien imaginer retourner la liste d’actions\nà lancer ou encore les <em>stores</em> à initialiser voire même un descripteur des données nécessaires\nà la vue (<a href=\"https://www.youtube.com/watch?v=9sc8Pyc51uU\">cf Relay / GraphQL</a>)</p>\n<p>Ensuite, lorsque le callback fourni à <code>Router.run()</code> est appelé, il suffit de parcourir\nles <em>Handler</em> pour récupérer les informations contenues dans les blocs <code>statics</code>,\nles traiter et enfin faire <code>React.render()</code>.</p>\n<pre><code class=\"language-Javascript\"><span class=\"hljs-comment\">// On renvoie une promesse qui sera résolue lorsque que toutes les données démandées via fetchData seront reçues.</span>\nRouter.run(routes, Router.HistoryLocation, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">Handler, state</span>) </span>{\n  <span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-built_in\">Promise</span>.all(state.routes\n    .filter(route =&gt; route.handler.fetchData)  <span class=\"hljs-comment\">// définit fetchData</span>\n    .map(route =&gt; {\n      <span class=\"hljs-keyword\">return</span> route.handler.fetchData(state.params);\n    })\n  );\n  p.then( x =&gt; {\n    React.render(<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">Handler</span> {<span class=\"hljs-attribute\">...state</span>} /&gt;</span>, document.getElementById(\"react-app\"))\n  });\n});</span></code></pre>\n<p>Le principe est simple et peut être facilement encapsulé dans un module pour\nêtre partagé entre le client et le serveur.  J’espère que cet article vous a permis\nd’appréhender un peu mieux le rendu coté serveur d’une application React.\nN’hésitez pas à laisser des commentaires si vous avez des questions où\nsi vous souhaitez partager vos expériences dans ce domaine.</p>\n<p>Et quelques liens vidéo des sessions de la #reactjsconf :</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=XZfvW1a8Xac\">React.js Conf 2015 - react-router increases your productivity </a></li>\n<li><a href=\"https://www.youtube.com/watch?v=z5e7kWSHWTg\">React.js Conf 2015 - Hype!</a> : un aperçu des possibilités de react-router</li>\n</ul>\n","rawBody":"\nOn entend souvent parler d'applications JavaScript isomorphiques, et même si le\nnom ne [fait](https://news.ycombinator.com/item?id=8237449) [pas](https://twitter.com/wycats/status/566857009836724224)\n[l'unanimité](https://medium.com/the-thinkmill/making-the-case-for-progressive-javascript-a98dfa82b9d7),\nce qu'il y a derrière, le concept de _server side rendered JavaScript_ est en\npasse de devenir  un sujet plutôt tendance pour 2015 grâce à la monté en puissance\nde [Reactjs](http://facebook.github.io/react/).  Faire du rendu d'application\nJavaScript coté serveur permet de réconcilier enfin le développeur de\n*Single Page App* (SPA) avec l’amélioration progressive, l'accessibilité et le\nSEO&nbsp;; quoique Google comme les lecteurs d'écran ont plutôt bien évolué sur\nce point. L'autre avantage non négligeable à mon sens, est qu'on améliore les\nperformances perçues par rapport\n à une SPA classique puisque&nbsp;:\n\n - On supprime une requête *ajax* au démarrage pour récupérer le contenu\n   initial.\n - On améliore la vitesse de rendu initial de page.\n - On bénéficie de la fluidité de navigation d'une SPA.\n\nPour plus d'info sur les avantages, il y a [cet article](http://tech.m6web.fr/isomorphic-single-page-app-parfaite-react-flux/) sur le blog de M6Tech.\n\nAfin de me familiariser avec React et son écosystème, rien de mieux que mettre\nles mains dedans&nbsp;! C'est un peu pour toutes ces raisons que j'ai décidé de\nl'utiliser pour mon site web (un site statique).\n\n**Inutile et donc totalement justifié pour le développeur que je suis**.\nUne des premières briques que j'ai mises en place a été le routeur.\n\n##react-router\nPour une fois dans la communauté JavaScript, il y a une bibliothèque de référence\net c'est celle là : [react-router](https://github.com/rackt/react-router).\nLe routeur est fortement inspiré par celui d'Ember au sens où les URL et leurs routes\nsont au cœur du dispositif. Le routeur se présente sous forme de composant React\net ça donne ça.\n\n```jsx\n//routes.js\n\nvar React = require(\"react\");\nvar Router = require(\"react-router\");\n\nvar Route = Router.Route;\nvar DefaultRoute = Router.DefaultRoute;\nvar NotFoundRoute = Router.NotFoundRoute;\n\nvar App = require(\"./app\");\nvar Home = require(\"./home/homePage\");\nvar Project = require(\"./project/projectPage\");\nvar NotFound = require(\"./notFound\");\n\nvar routes = (\n  <Route path=\"/\" handler={App}>\n    <DefaultRoute name=\"index\" handler={Home} />\n    <Route name=\"project\" path=\"/projects/:url\" handler={Project} />\n    <NotFoundRoute name=\"404\" handler={NotFound} />\n  </Route>\n);\n\nmodule.exports = routes;\n```\n\nÀ mon sens, l'aspect déclaratif apporte de la clarté et améliore la compréhension\ndu système. On voit rapidement quel composant est utilisé en fonction de l'URL.\nL'autre avantage du déclaratif, c'est qu'il permet de manière assez simple,\nd'imbriquer les routes en imbriquant les nœuds `<Route>`.\n\nEn plus des composants, on a aussi à disposition des *mixins* pour naviguer\nprogrammatiquement ou accéder aux infos du routeur (chemin, paramètres, ...)\n\nEt le gros plus de cette bibliothèque : elle peut aussi s'utiliser coté serveur,\npour la génération des vues et éviter ainsi de dupliquer du code puisqu'on va\npouvoir carrément utiliser tel quel le fichier précédent. Plutôt cool&nbsp;!\nVoici un exemple de *middleware* pour faire marcher ça dans Express&nbsp;:\n\n```javascript\nvar React = require(\"react\");\nvar Router = require(\"react-router\");\n\n// notre fichier routes.js\nvar routes = require(\"./src/routes\");\n// notre template de page html\nvar Html = require(\"./src/html\");\n\nfunction reactView(req, res, next) {\n  Router.run(routes, req.url, function (Handler, state) {\n    // on récupère les données pour cette vue en fonction de la requête.\n    var data = getViewData(req);\n\n    // on génère la soupe au tag avec nos données dedans\n    var markup = React.renderToString(React.createElement(Handler), data);\n\n    // on utilise React comme moteur de template\n    var HtmlElement = React.createElement(Html, {markup: markup});\n    res.send(\"<!DOCTYPE html>\" +  React.renderToStaticMarkup(HtmlElement));\n  });\n}\n```\nEt voici le composant `Html.jsx` que l'on utilise comme *template* pour notre page principale.\n\n```jsx\nvar React = require('react');\n\nvar Html = React.createClass({\n  render: function() {\n    return (\n      <html>\n        <head>\n          <meta charSet=\"utf-8\"></meta>\n          <title>Mon site perso</title>\n          <script src=\"/js/app.js\" />\n        </head>\n        <body>\n          <div id=\"react-app\" dangerouslySetInnerHTML={{__html: this.props.markup}} />\n        </body>\n      </html>\n    );\n  }\n\n});\n\nmodule.exports = Html;\n```\nUne fois que le code HTML a été généré via`React.renderToString(React.createElement(Handler), data);`,\non pourrait utiliser n'importe quel moteur de template (lodash.template, handlebars, ejs, jade, PHP...)\npour générer le HTML de la page à renvoyer. Dans un souci de rationalisation des outils,\nj'ai préféré utiliser React.\n\nVous avez dû vous apercevoir qu'on utilise 2 méthodes différentes pour générer\ndu HTML avec React&nbsp;:\n- `React.renderToString(React.createElement(Handler), data);`\n- `React.renderToStaticMarkup(React.createElement(Handler), data);`\n\nLa différence entre les deux méthodes est simple. Dans la première, React annote\nles nœuds HTML avec des `data-reactid` dans le but de pouvoir ensuite reprendre\nla main lorsque votre l'application s'exécutera dans le navigateur. De cette manière,\nReact sait que vous l'initialisez avec un contenu généré depuis le serveur.\nEt si il détecte une différence entre le code existant et celui qu'il génère,\nvous aurez droit à un [petit warning](https://github.com/facebook/react/blob/2aeb8a2a6beb00617a4217f7f8284924fa2ad819/src/browser/ui/__tests__/ReactRenderDocument-test.js#L205-L215).\nLa deuxième méthode permet de générer du code HTML sans annotations,\ncomme n'importe quel moteur de *template*.\n\nLes plus attentifs auront remarqué qu'on passe les données initiales lors de\nla création de l'application via des *props* React. Quid de l'utilisation\nde flux dans tout ça ?\n\n## Flux et le rendu serveur\nAvec [Flux](http://facebook.github.io/flux/), ce sont les stores qui maintiennent\nl'état de notre application. Si l'on ne veut pas afficher notre application\nsans aucune données, nous allons devoir préalablement peupler nos stores\navant d'appeler `React.renderToString()`.\n\nLà où ça se corse un peu, c'est qu'il va falloir remplir nos stores avant de démarrer\nnotre application sous peine de voir le message d'alerte dont je parlais plus haut.\nLe plus simple alors est de passer ces données au moteur de template,\nen plus du markup (par exemple sous la forme d'un nœud `<script type=\"application/json\">JSON DATA</script>`.\nIl ne reste plus qu'a récupérer ces données avant d’appeler `React.render( Application, document.getElementById(\"react-app\"))`\n\nPar exemple&nbsp;:\n\n```javascript\ndocument.addEventListener(\"DOMContentLoaded\", function(event) {\n  // getData() va récuperer et parser le contenu du tag script\n  // qui contient nos données\n  var storeData= getData();\n\n  // on déclenche une actions\n  actions.init( storeData);\n\n  // on lance le rendu\n  React.render(<App />, document.getElementById(\"react-app\"));\n});\n```\n\n## Le mot de la fin\nPenser son application React pour qu'elle puisse être rendue coté serveur\nintroduit de nouvelles problématiques, notamment avec l'ajout du *pattern* Flux.\nEn fonction des pages que l'on souhaite afficher, on devra initialiser différents *stores*.\nÀ nous de déterminer, en fonction de l'URL et du composant à afficher,\nlequel initialiser, et cela, que l'on soit sur le client ou le serveur.\nDe la même manière, il faudra être capable de charger nos données, indépendamment\nde l'environnement d’exécution (coucou XHR).\n\nUn début de réponse se trouve dans les exemples fournis avec react-router.\nL'idée est de passer par une propriété `statics` lors de la création des composants React\nqui seront associés à une `<Route/>`.\n\n```jsx\n\nvar ProjectPage = React.createClass({\n  statics: {\n    fetchData: function(params){\n      return api.getPageData(params.url)\n        .then( actions.initProject)\n        .catch( actions.loadProjectError);\n    }\n  }\n ...\n });\n```\n\nDans ce bloc `statics`, on définit une fonction qui servira à récupérer les données\npour ce composant mais on pourrait très bien imaginer retourner la liste d'actions\nà lancer ou encore les *stores* à initialiser voire même un descripteur des données nécessaires\nà la vue ([cf Relay / GraphQL](https://www.youtube.com/watch?v=9sc8Pyc51uU))\n\nEnsuite, lorsque le callback fourni à `Router.run()` est appelé, il suffit de parcourir\nles *Handler* pour récupérer les informations contenues dans les blocs `statics`,\nles traiter et enfin faire `React.render()`.\n\n```Javascript\n// On renvoie une promesse qui sera résolue lorsque que toutes les données démandées via fetchData seront reçues.\nRouter.run(routes, Router.HistoryLocation, function (Handler, state) {\n  var p = Promise.all(state.routes\n    .filter(route => route.handler.fetchData)  // définit fetchData\n    .map(route => {\n      return route.handler.fetchData(state.params);\n    })\n  );\n  p.then( x => {\n    React.render(<Handler {...state} />, document.getElementById(\"react-app\"))\n  });\n});\n```\nLe principe est simple et peut être facilement encapsulé dans un module pour\nêtre partagé entre le client et le serveur.  J'espère que cet article vous a permis\nd'appréhender un peu mieux le rendu coté serveur d'une application React.\nN'hésitez pas à laisser des commentaires si vous avez des questions où\nsi vous souhaitez partager vos expériences dans ce domaine.\n\nEt quelques liens vidéo des sessions de la #reactjsconf :\n- [React.js Conf 2015 - react-router increases your productivity ](https://www.youtube.com/watch?v=XZfvW1a8Xac)\n- [React.js Conf 2015 - Hype!](https://www.youtube.com/watch?v=z5e7kWSHWTg) : un aperçu des possibilités de react-router\n","raw":"---\ndate: \"2015-02-23\"\ntitle: Quelques retours sur React et le rendu serveur\ntags:\n  - javascript\n  - react\nauthors:\n  - lionelB\n---\n\nOn entend souvent parler d'applications JavaScript isomorphiques, et même si le\nnom ne [fait](https://news.ycombinator.com/item?id=8237449) [pas](https://twitter.com/wycats/status/566857009836724224)\n[l'unanimité](https://medium.com/the-thinkmill/making-the-case-for-progressive-javascript-a98dfa82b9d7),\nce qu'il y a derrière, le concept de _server side rendered JavaScript_ est en\npasse de devenir  un sujet plutôt tendance pour 2015 grâce à la monté en puissance\nde [Reactjs](http://facebook.github.io/react/).  Faire du rendu d'application\nJavaScript coté serveur permet de réconcilier enfin le développeur de\n*Single Page App* (SPA) avec l’amélioration progressive, l'accessibilité et le\nSEO&nbsp;; quoique Google comme les lecteurs d'écran ont plutôt bien évolué sur\nce point. L'autre avantage non négligeable à mon sens, est qu'on améliore les\nperformances perçues par rapport\n à une SPA classique puisque&nbsp;:\n\n - On supprime une requête *ajax* au démarrage pour récupérer le contenu\n   initial.\n - On améliore la vitesse de rendu initial de page.\n - On bénéficie de la fluidité de navigation d'une SPA.\n\nPour plus d'info sur les avantages, il y a [cet article](http://tech.m6web.fr/isomorphic-single-page-app-parfaite-react-flux/) sur le blog de M6Tech.\n\nAfin de me familiariser avec React et son écosystème, rien de mieux que mettre\nles mains dedans&nbsp;! C'est un peu pour toutes ces raisons que j'ai décidé de\nl'utiliser pour mon site web (un site statique).\n\n**Inutile et donc totalement justifié pour le développeur que je suis**.\nUne des premières briques que j'ai mises en place a été le routeur.\n\n##react-router\nPour une fois dans la communauté JavaScript, il y a une bibliothèque de référence\net c'est celle là : [react-router](https://github.com/rackt/react-router).\nLe routeur est fortement inspiré par celui d'Ember au sens où les URL et leurs routes\nsont au cœur du dispositif. Le routeur se présente sous forme de composant React\net ça donne ça.\n\n```jsx\n//routes.js\n\nvar React = require(\"react\");\nvar Router = require(\"react-router\");\n\nvar Route = Router.Route;\nvar DefaultRoute = Router.DefaultRoute;\nvar NotFoundRoute = Router.NotFoundRoute;\n\nvar App = require(\"./app\");\nvar Home = require(\"./home/homePage\");\nvar Project = require(\"./project/projectPage\");\nvar NotFound = require(\"./notFound\");\n\nvar routes = (\n  <Route path=\"/\" handler={App}>\n    <DefaultRoute name=\"index\" handler={Home} />\n    <Route name=\"project\" path=\"/projects/:url\" handler={Project} />\n    <NotFoundRoute name=\"404\" handler={NotFound} />\n  </Route>\n);\n\nmodule.exports = routes;\n```\n\nÀ mon sens, l'aspect déclaratif apporte de la clarté et améliore la compréhension\ndu système. On voit rapidement quel composant est utilisé en fonction de l'URL.\nL'autre avantage du déclaratif, c'est qu'il permet de manière assez simple,\nd'imbriquer les routes en imbriquant les nœuds `<Route>`.\n\nEn plus des composants, on a aussi à disposition des *mixins* pour naviguer\nprogrammatiquement ou accéder aux infos du routeur (chemin, paramètres, ...)\n\nEt le gros plus de cette bibliothèque : elle peut aussi s'utiliser coté serveur,\npour la génération des vues et éviter ainsi de dupliquer du code puisqu'on va\npouvoir carrément utiliser tel quel le fichier précédent. Plutôt cool&nbsp;!\nVoici un exemple de *middleware* pour faire marcher ça dans Express&nbsp;:\n\n```javascript\nvar React = require(\"react\");\nvar Router = require(\"react-router\");\n\n// notre fichier routes.js\nvar routes = require(\"./src/routes\");\n// notre template de page html\nvar Html = require(\"./src/html\");\n\nfunction reactView(req, res, next) {\n  Router.run(routes, req.url, function (Handler, state) {\n    // on récupère les données pour cette vue en fonction de la requête.\n    var data = getViewData(req);\n\n    // on génère la soupe au tag avec nos données dedans\n    var markup = React.renderToString(React.createElement(Handler), data);\n\n    // on utilise React comme moteur de template\n    var HtmlElement = React.createElement(Html, {markup: markup});\n    res.send(\"<!DOCTYPE html>\" +  React.renderToStaticMarkup(HtmlElement));\n  });\n}\n```\nEt voici le composant `Html.jsx` que l'on utilise comme *template* pour notre page principale.\n\n```jsx\nvar React = require('react');\n\nvar Html = React.createClass({\n  render: function() {\n    return (\n      <html>\n        <head>\n          <meta charSet=\"utf-8\"></meta>\n          <title>Mon site perso</title>\n          <script src=\"/js/app.js\" />\n        </head>\n        <body>\n          <div id=\"react-app\" dangerouslySetInnerHTML={{__html: this.props.markup}} />\n        </body>\n      </html>\n    );\n  }\n\n});\n\nmodule.exports = Html;\n```\nUne fois que le code HTML a été généré via`React.renderToString(React.createElement(Handler), data);`,\non pourrait utiliser n'importe quel moteur de template (lodash.template, handlebars, ejs, jade, PHP...)\npour générer le HTML de la page à renvoyer. Dans un souci de rationalisation des outils,\nj'ai préféré utiliser React.\n\nVous avez dû vous apercevoir qu'on utilise 2 méthodes différentes pour générer\ndu HTML avec React&nbsp;:\n- `React.renderToString(React.createElement(Handler), data);`\n- `React.renderToStaticMarkup(React.createElement(Handler), data);`\n\nLa différence entre les deux méthodes est simple. Dans la première, React annote\nles nœuds HTML avec des `data-reactid` dans le but de pouvoir ensuite reprendre\nla main lorsque votre l'application s'exécutera dans le navigateur. De cette manière,\nReact sait que vous l'initialisez avec un contenu généré depuis le serveur.\nEt si il détecte une différence entre le code existant et celui qu'il génère,\nvous aurez droit à un [petit warning](https://github.com/facebook/react/blob/2aeb8a2a6beb00617a4217f7f8284924fa2ad819/src/browser/ui/__tests__/ReactRenderDocument-test.js#L205-L215).\nLa deuxième méthode permet de générer du code HTML sans annotations,\ncomme n'importe quel moteur de *template*.\n\nLes plus attentifs auront remarqué qu'on passe les données initiales lors de\nla création de l'application via des *props* React. Quid de l'utilisation\nde flux dans tout ça ?\n\n## Flux et le rendu serveur\nAvec [Flux](http://facebook.github.io/flux/), ce sont les stores qui maintiennent\nl'état de notre application. Si l'on ne veut pas afficher notre application\nsans aucune données, nous allons devoir préalablement peupler nos stores\navant d'appeler `React.renderToString()`.\n\nLà où ça se corse un peu, c'est qu'il va falloir remplir nos stores avant de démarrer\nnotre application sous peine de voir le message d'alerte dont je parlais plus haut.\nLe plus simple alors est de passer ces données au moteur de template,\nen plus du markup (par exemple sous la forme d'un nœud `<script type=\"application/json\">JSON DATA</script>`.\nIl ne reste plus qu'a récupérer ces données avant d’appeler `React.render( Application, document.getElementById(\"react-app\"))`\n\nPar exemple&nbsp;:\n\n```javascript\ndocument.addEventListener(\"DOMContentLoaded\", function(event) {\n  // getData() va récuperer et parser le contenu du tag script\n  // qui contient nos données\n  var storeData= getData();\n\n  // on déclenche une actions\n  actions.init( storeData);\n\n  // on lance le rendu\n  React.render(<App />, document.getElementById(\"react-app\"));\n});\n```\n\n## Le mot de la fin\nPenser son application React pour qu'elle puisse être rendue coté serveur\nintroduit de nouvelles problématiques, notamment avec l'ajout du *pattern* Flux.\nEn fonction des pages que l'on souhaite afficher, on devra initialiser différents *stores*.\nÀ nous de déterminer, en fonction de l'URL et du composant à afficher,\nlequel initialiser, et cela, que l'on soit sur le client ou le serveur.\nDe la même manière, il faudra être capable de charger nos données, indépendamment\nde l'environnement d’exécution (coucou XHR).\n\nUn début de réponse se trouve dans les exemples fournis avec react-router.\nL'idée est de passer par une propriété `statics` lors de la création des composants React\nqui seront associés à une `<Route/>`.\n\n```jsx\n\nvar ProjectPage = React.createClass({\n  statics: {\n    fetchData: function(params){\n      return api.getPageData(params.url)\n        .then( actions.initProject)\n        .catch( actions.loadProjectError);\n    }\n  }\n ...\n });\n```\n\nDans ce bloc `statics`, on définit une fonction qui servira à récupérer les données\npour ce composant mais on pourrait très bien imaginer retourner la liste d'actions\nà lancer ou encore les *stores* à initialiser voire même un descripteur des données nécessaires\nà la vue ([cf Relay / GraphQL](https://www.youtube.com/watch?v=9sc8Pyc51uU))\n\nEnsuite, lorsque le callback fourni à `Router.run()` est appelé, il suffit de parcourir\nles *Handler* pour récupérer les informations contenues dans les blocs `statics`,\nles traiter et enfin faire `React.render()`.\n\n```Javascript\n// On renvoie une promesse qui sera résolue lorsque que toutes les données démandées via fetchData seront reçues.\nRouter.run(routes, Router.HistoryLocation, function (Handler, state) {\n  var p = Promise.all(state.routes\n    .filter(route => route.handler.fetchData)  // définit fetchData\n    .map(route => {\n      return route.handler.fetchData(state.params);\n    })\n  );\n  p.then( x => {\n    React.render(<Handler {...state} />, document.getElementById(\"react-app\"))\n  });\n});\n```\nLe principe est simple et peut être facilement encapsulé dans un module pour\nêtre partagé entre le client et le serveur.  J'espère que cet article vous a permis\nd'appréhender un peu mieux le rendu coté serveur d'une application React.\nN'hésitez pas à laisser des commentaires si vous avez des questions où\nsi vous souhaitez partager vos expériences dans ce domaine.\n\nEt quelques liens vidéo des sessions de la #reactjsconf :\n- [React.js Conf 2015 - react-router increases your productivity ](https://www.youtube.com/watch?v=XZfvW1a8Xac)\n- [React.js Conf 2015 - Hype!](https://www.youtube.com/watch?v=z5e7kWSHWTg) : un aperçu des possibilités de react-router\n","__filename":"fr/articles/js/react/cote-serveur/index.md","__url":"/fr/articles/js/react/cote-serveur/"}