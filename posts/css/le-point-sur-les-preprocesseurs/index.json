{"head":{"layout":"Post","comments":true,"date":"2014-03-11","title":"Le point sur les pré-processeurs CSS","tags":["css","pré-processeur","post-processeur"],"authors":["MoOx"]},"body":"<h2 id=\"pourquoi-les-pr-processeurs\"><a class=\"markdownIt-Anchor\" href=\"#pourquoi-les-pr-processeurs\">#</a> Pourquoi les pré-processeurs</h2>\n<p>Voilà ce que j’ai écrit en 2011 dans\n<a href=\"http://moox.io/blog/utiliser-des-variables-fonctions-css/\">mon premier post sur les pré-processeur</a>.\nJe venais de découvrir cette notion et j’avais donc fait le tour de la question.</p>\n<blockquote>\n<p>Le langage des CSS n’a pas de côté dynamique. C’est lui avec lequel, à chaque\nfois qu’on intègre une maquette graphique, on doit se taper tout de zéro.\nIl a beau exister des CSS « Reset », des frameworks CSS, tout un tas de\ngrilles prête à l’emploi, des composants de CSS réutilisables avec l’approche\nobjet, je n’ai jamais réellement été satisfait par ces méthodes, que ce soit\nà cause des contraintes qu’impose la syntaxe (devoir mettre des classes à tout\nva dans l’HTML ça peut vite devenir chiant dans un CMS), ou par d’éventuelles\nlimitations qui obligent à « trop » modifier la source du document (pas assez\nde, ou trop de, ou seulement ça ne me plait pas comment c’est fait).</p>\n</blockquote>\n<p>J’avais tout dit, même des trucs qu’aujourd’hui je pense être des conneries (il\nn’y a que les cons qui ne changent pas d’avis + c’est en faisant des erreurs\nqu’on apprend le mieux), mais je reviendrais dessus plus tard.</p>\n<p>Du coup on en retire quoi ? Qu’utiliser un pré-processeur se justifie par\nl’ajout de fonctionnalités lorsque vous écrivez des feuilles de style (en tant\nque développeur). En tant qu’utilisateur du code produit, cela va permettre\nd’ajouter une couche abstraction (ce qui peut poser des problèmes, je reviendrais\nsur ce point plus tard).</p>\n<h2 id=\"principales-fonctionnalit-s\"><a class=\"markdownIt-Anchor\" href=\"#principales-fonctionnalit-s\">#</a> Principales fonctionnalités</h2>\n<ul>\n<li>variables</li>\n<li>fonctions</li>\n<li>mixins (permettant de réaliser des sorties CSS paramétrables)</li>\n<li><code>@import</code> intelligent (pas côté client)</li>\n<li>nesting (imbrications des sélecteurs pour éviter la répétition)</li>\n<li>optimisation et abstraction poussée (via les mixins, placeholders et <code>@extend</code>)</li>\n</ul>\n<p>Anciennement on aurait rajouté à cette liste la gestion du CSS 3, mais comme\nje l’expliquais il y a peu, ce n’est plus nécessaire, on a une méthode bien\nmieux, rapide et surtout <b>maintenu à jour</b> avec\n<a href=\"/posts/css/comment-en-finir-avec-les-prefixes/\">AutoPrefixer</a></p>\n<h2 id=\"les-principaux-pr-processeurs\"><a class=\"markdownIt-Anchor\" href=\"#les-principaux-pr-processeurs\">#</a> Les principaux pré-processeurs</h2>\n<h3 id=\"sass\"><a class=\"markdownIt-Anchor\" href=\"#sass\">#</a> <a href=\"http://sass-lang.com/\">Sass</a></h3>\n<p>Sass est à mon avis le plus mature des pré-processeurs CSS.\nIl possède 2 syntaxes (une indentée et une plus proche de CSS).\nCe projet avance à bon rythme. Niveau fonctionnalités, rien à dire si ce n’est que\ncelui-ci a un petit plus pour avec la feature <code>@content</code> qui permet pour le coup de\npasser tout un bloc de propriétés en paramètre à des mixins. Ce qui est super\npratique lorsque l’on écrit pas mal de media queries.\n(Après, venez pas me dire qu’on a plein de fois les media-queries qui se\nrépètent et que ce n’est pas bien pour la taille du fichier, gzip se chargera de ça -\n<small><a href=\"https://twitter.com/kaelig/status/412909849207644160\">exemple similaire</a>)</small>.</p>\n<p>Le langage Sass possède une implémentation d’origine en Ruby mais aussi depuis\nquelques temps une implémentation C qui se veut beaucoup plus rapide et portable:\n<a href=\"http://libsass.org/\">libsass</a> mais qui est encore un peu en retard niveau\nfonctionnalité (affaire à suivre). Surtout depuis la version 3.3 qui possède de\nnouvelles fonctionnalités (comme les maps, entre autres).</p>\n<p>Avec ce pré-processeur, on peut s’éloigner pas mal du CSS natif, que ce soit avec\nla syntaxe ou l’aspect programmation (il n’y a qu’à voir des trucs comme\n<a href=\"https://github.com/Team-Sass/modular-scale\">modular-scale</a> ou\n<a href=\"https://github.com/HugoGiraudel/SassyMatrix\">SassyMatrix</a>).</p>\n<p>Bibliotèques construites sur Sass :</p>\n<ul>\n<li><a href=\"http://compass-style.org/\">Compass</a>, solide, basé sur Ruby (incompatible libsass),</li>\n<li><a href=\"http://bourbon.io/\">Bourbon</a>, plus light mais plus rapide.</li>\n</ul>\n<h3 id=\"less\"><a class=\"markdownIt-Anchor\" href=\"#less\">#</a> <a href=\"http://lesscss.org/\">LESS</a></h3>\n<p>Je n’ai pas trop envie de parler de ce pré-processeur assez classique, qui a fait un\nchoix assez étrange pour les variables par exemple (oui, <code>@</code> est un caractère\nspécial en CSS, c’est assez étrange de rajouter une couche avec pour les variables\navec ce dernier).\nJ’espère seulement que ceux qui l’utilisent aujourd’hui n’utilise pas le script côté client\n(ce qui provoquerait un affichage sans CSS si le client n’a pas JavaScript activé).\nBien qu’il soit populaire, le repository sur GitHub n’est pas signe de bonne santé\nà mes yeux. Voir des pull-requests qui traînent vielles de plusieurs\n<del>mois</del> <ins>années</ins> me laissent dubitatif…\nPuis il n’y a qu’à voir l’exemple sur la homepage du site avec les box-shadow,\npour voir que ce pré-processeur est assez déprécié.</p>\n<p>Ajoutons à cela le fait que Twitter Boostrap a (enfin) une version Sass…</p>\n<p>Côté fonctionnalités, l’aspect programmation est assez laborieux avec la façon dont\nsont gérés les mixins conditionnels. Je passe sur ce point gerbant.</p>\n<p>Bibliotèques construites sur Less :</p>\n<ul>\n<li><a href=\"http://lesshat.madebysource.com/\">LESS Hat</a>,</li>\n<li><a href=\"http://www.lesselements.com/\">LESS Elements</a>.</li>\n</ul>\n<h3 id=\"stylus\"><a class=\"markdownIt-Anchor\" href=\"#stylus\">#</a> <a href=\"http://learnboost.github.io/stylus/\">Stylus</a></h3>\n<p>Stylus se veut plus transparent que les autres pré-processeurs. C’est un point\nréussi puisqu’il permet d’avoir des mixins transparents au niveau écriture.\nCela peut par contre bien entendu rendre la maintenance et la compréhension plus\ndifficile si on en abuse.\nIl permet aussi de coder sans <code>{}</code> ni <code>:</code> ni <code>;</code> (bien que tout cela soit optionnel)</p>\n<p>Niveau fonctionnalités cela ne vaut pas Sass. Ici pas de <code>@content</code> ou de maps.</p>\n<p>Bibliotèque construite sur Stylus :</p>\n<ul>\n<li><a href=\"http://visionmedia.github.io/nib/\">Nib</a></li>\n</ul>\n<h3 id=\"alternatives\"><a class=\"markdownIt-Anchor\" href=\"#alternatives\">#</a> Alternatives</h3>\n<p>On peut s’amuser à faire un pré-processeur CSS avec n’importe quel langage c’est\névident.\nMais <a href=\"http://www.alsacreations.com/astuce/lire/1433-utiliser-php-pour-gerer-vos-styles-css.html\">les enfants, ne faites pas ça.</a>\nÀ moins que vous souhaitiez alourdir vos CSS plus que vous y gagnerez.\nPuis si c’est juste pour ajouter des variables, il existe d’autres solutions…</p>\n<p><em>Note: si vous avez d’autres pré-processeurs intéressants, je me ferais un plaisir\nde les ajouter ici. Mais bon <a href=\"https://github.com/putaindecode/putaindecode.fr/blob/master/pages/posts/css/le-point-sur-les-preprocesseurs/index.md\">vous pouvez aussi le faire tout seul comme un\ngrand</a>.</em></p>\n<h2 id=\"les-pr-processeurs-sont-ils-vraiment-n-cessaire\"><a class=\"markdownIt-Anchor\" href=\"#les-pr-processeurs-sont-ils-vraiment-n-cessaire\">#</a> Les pré-processeurs sont-ils vraiment nécessaire ?</h2>\n<blockquote>\n<p>Oula. Le mec vient de nous poser un post pour nous parler des pré-processeurs,\net il nous sort une question comme ça ? Il est où le piège ?</p>\n</blockquote>\n<p>Si je pose la question c’est que j’ai une petite réponse par là. Et elle ne va\npeut-être pas vous plaire.</p>\n<p>Je vais revenir sur certains points qui peuvent poser problème avec les pré-processeurs.</p>\n<h3 id=\"le-nesting-cay-mal\"><a class=\"markdownIt-Anchor\" href=\"#le-nesting-cay-mal\">#</a> Le nesting cay mal</h3>\n<p>Ahh… Le nesting, c’est bien pratique lorsque l’on travaille sur un CMS\n(ou n’importe quoi ayant un code HTML qu’on ne maitrise pas facilement)\nde pouvoir utiliser le nesting pour pouvoir rapidement produire les sélecteurs adéquats.\nMais en terme de maintenance et surtout de réutilisation, c’est vraiment à chier.\nFaut dire ce qui est.</p>\n<pre><code class=\"language-scss\"><span class=\"hljs-class\">.widget</span> {\n  <span class=\"hljs-comment\">// titre</span>\n  <span class=\"hljs-tag\">h3</span> { }\n\n  <span class=\"hljs-comment\">// widget body</span>\n  &gt; <span class=\"hljs-tag\">div</span> {\n\n    <span class=\"hljs-comment\">// liste</span>\n    <span class=\"hljs-tag\">ul</span> {\n\n    }\n  }\n}</code></pre>\n<p>Cet exemple est parfait pour démontrer les limites du nesting.\nComment faire si, sur un widget donnée, nous avons comme titre un h2 ou h4 ?\nIl faut alourdir la CSS. Pareillement, si notre fameuse liste dans le corps n’est\npas dans la même arborescence que celle décrite, il faut à nouveau alourdir notre CSS.\nSans rentrer dans ces solutions solides (nous parlerons de BEM très bientôt),\ncette solution serait bien plus élégante pour la réutilisation :</p>\n<pre><code class=\"language-css\"><span class=\"hljs-class\">.widget</span> <span class=\"hljs-rules\">{}</span>\n\n  <span class=\"hljs-class\">.widget-title</span> <span class=\"hljs-rules\">{ }</span>\n\n  <span class=\"hljs-class\">.widget-body</span> <span class=\"hljs-rules\">{ }</span>\n\n    <span class=\"hljs-class\">.widget-body-list</span> <span class=\"hljs-rules\">{ }</span></code></pre>\n<p>Vous remarquerez que j’ai un code ici beaucoup plus compréhensible par un nouveau,\nmais aussi bien mieux réutilisable et surtout, point très important, non couplé\n(non dépendant) à notre arborescence HTML (coucou le DOM).\nDe plus, utiliser le nesting provoque des sélecteurs à rallonges, après c’est la\ncourse à la longueur (et au poids) des sélecteurs quand il faut surcharger une\nrègle héritée.\nAvec de simple sélecteurs, pas de souci de ce genre là.</p>\n<p><em>ProTip™ : vous remarquerez que j’indente mon CSS à l’image des composants, ça mange\npas de pain, est cela facilite la lecture, moins linéaire.</em></p>\n<p>Donc je reviens sur ce que je disais, il faut utiliser pleins de classes dans l’HTML.\nÇa sert à ça. Votre CSS produit de cette façon sera bien plus réutilisable.</p>\n<h3 id=\"l-abstraction-cay-dangereux\"><a class=\"markdownIt-Anchor\" href=\"#l-abstraction-cay-dangereux\">#</a> L’abstraction cay dangereux</h3>\n<p>On en revient à la magie. Lorsqu’on a trop de couche qui cache ce qu’il y a\nréellement sous le capot, <a href=\"http://linuxfr.org/news/encore-un-exemple-de-code-spaghetti-toyota\">on peut vite perdre le contrôle</a>.</p>\n<p>Et voici <a href=\"https://github.com/MoOx/compass-recipes/issues/104\">un parfait exemple</a>\noù un utilisateur de ma bibliothèque <a href=\"https://github.com/MoOx/compass-recipes\">Compass Recipes</a>\navait un problème lorsqu’il utilisait 2 mixins qui cachaient trop de code.\nDans  notre cas corners-tucked (version coin scotché) et background-noise (bruit visuel).\nIl en a perdu des choses simples et avait passé beaucoup de temps à se prendre la tête\nalors que la solution était très (trop) simple (une histoire entre <code>background-image</code>\net le shorthand <code>background</code>).</p>\n<p>Je me laisse souvent attirer par la magie d’un code, mais mon expérience m’indique\naujourd’hui qu’il ne faut pas abuser de cette partie mystérieuse où l’on ne sait\nplus ce qui se passe.</p>\n<p>Je vous laisse imaginer du nesting caché dans des mixins qui utilisent d’autres mixins\nqui font des @extends de placeholders…</p>\n<blockquote>\n<p>Un grand pouvoir implique de grandes responsabilités.</p>\n</blockquote>\n<p>Tout est dit. Il faut faire attention. Très attention.</p>\n<h2 id=\"mon-avis-sur-les-pr-processeurs\"><a class=\"markdownIt-Anchor\" href=\"#mon-avis-sur-les-pr-processeurs\">#</a> Mon avis sur les pré-processeurs</h2>\n<p>Je pense que les pré-processeurs restent utiles mais seulement pour des projets\nde très grosse envergure, qui possède énormément de code CSS et/ou extrêmement dynamique.\nOu que vous utilisez de solutions comme <a href=\"http://getbootstrap.com/\">Bootstrap</a> ou\n<a href=\"http://foundation.zurb.com/\">Foundation</a>, chose que je déconseille pour autre chose que des prototypes.</p>\n<p>De part mon expérience et mon recul (si si j’en prends je vous jure), je pense que\nj’aurais pu m’en passer bien plus souvent que j’ai voulu l’admettre par le passé.\nMais bon comme je dis souvent, quel plaisir de se planter quand ce n’est pas dans un platane !</p>\n<p>Ce qu’il faut retenir clairement c’est que ce ne sont pas les pré-processeurs qui\nvont vous faire écrire des meilleurs feuilles de styles. C’est plus un travail sur\nune méthodologie et  une organisation adaptées à vos besoins qui amélioreront\nvotre quotidien de webdesigner (oui quoi, dès qu’on code du CSS, on peut\nutiliser l’appellation webdesigner sur son CV, ça en jette).</p>\n<p>J’ai donc longtemps apprécié les pré-processeurs CSS, mais aujourd’hui je commence\nà leur tourner le dos du fait que je n’utilise que trop peu de leurs fonctionnalités.\nJ’évite l’overkill quoi.</p>\n<p>Quand on voit que des <em>grands</em> de l’HTML / CSS comme <a href=\"http://nicolasgallagher.com/\">@necolas</a>\nn’utilise pas de pré-processeur, on a de quoi se poser des questions.\nAvec une bonne bibliothèque comme <a href=\"https://github.com/suitcss/suit/\">SUIT CSS</a>,\non s’en retrouve à ne manquer que des petites choses.</p>\n<p>Que l’on peut combler.</p>\n<p>Avec les post-processeurs par exemple.</p>\n<p>J’ai donc à ce jour moi aussi conservé une couche pour ajouter le minimum vital en tant que développeur.</p>\n<p>Mais ne voulant pas alourdir ce post consacré aux pré-processeurs CSS,\nvous pourrez continuer la lecture au prochain épisode qui sera consacré aux post-processeurs…</p>\n<p><small>(Mamam, t’as vu ce cliffhanger digne des séries US !)</small></p>\n<p><s>Bon promis la prochaine fois je vous en parle des post-processeurs. Pour de vrai.</s>\nChose promise, chose due : <a href=\"/posts/css/les-post-processeurs/\">Les post-processeurs CSS</a></p>\n","rawBody":"\n## Pourquoi les pré-processeurs\n\nVoilà ce que j'ai écrit en 2011 dans\n[mon premier post sur les pré-processeur](http://moox.io/blog/utiliser-des-variables-fonctions-css/).\nJe venais de découvrir cette notion et j'avais donc fait le tour de la question.\n\n> Le langage des CSS n’a pas de côté dynamique. C’est lui avec lequel, à chaque\nfois qu’on intègre une maquette graphique, on doit se taper tout de zéro.\nIl a beau exister des CSS « Reset », des frameworks CSS, tout un tas de\ngrilles prête à l’emploi, des composants de CSS réutilisables avec l’approche\nobjet, je n’ai jamais réellement été satisfait par ces méthodes, que ce soit\nà cause des contraintes qu’impose la syntaxe (devoir mettre des classes à tout\nva dans l’HTML ça peut vite devenir chiant dans un CMS), ou par d’éventuelles\nlimitations qui obligent à « trop » modifier la source du document (pas assez\nde, ou trop de, ou seulement ça ne me plait pas comment c’est fait).\n\nJ'avais tout dit, même des trucs qu'aujourd'hui je pense être des conneries (il\nn'y a que les cons qui ne changent pas d'avis + c'est en faisant des erreurs\nqu'on apprend le mieux), mais je reviendrais dessus plus tard.\n\nDu coup on en retire quoi ? Qu'utiliser un pré-processeur se justifie par\nl'ajout de fonctionnalités lorsque vous écrivez des feuilles de style (en tant\nque développeur). En tant qu'utilisateur du code produit, cela va permettre\nd'ajouter une couche abstraction (ce qui peut poser des problèmes, je reviendrais\nsur ce point plus tard).\n\n## Principales fonctionnalités\n\n  - variables\n  - fonctions\n  - mixins (permettant de réaliser des sorties CSS paramétrables)\n  - `@import` intelligent (pas côté client)\n  - nesting (imbrications des sélecteurs pour éviter la répétition)\n  - optimisation et abstraction poussée (via les mixins, placeholders et `@extend`)\n\nAnciennement on aurait rajouté à cette liste la gestion du CSS 3, mais comme\nje l'expliquais il y a peu, ce n'est plus nécessaire, on a une méthode bien\nmieux, rapide et surtout <b>maintenu à jour</b> avec\n[AutoPrefixer](/posts/css/comment-en-finir-avec-les-prefixes/)\n\n## Les principaux pré-processeurs\n\n### [Sass](http://sass-lang.com/)\n\nSass est à mon avis le plus mature des pré-processeurs CSS.\nIl possède 2 syntaxes (une indentée et une plus proche de CSS).\nCe projet avance à bon rythme. Niveau fonctionnalités, rien à dire si ce n'est que\ncelui-ci a un petit plus pour avec la feature `@content` qui permet pour le coup de\npasser tout un bloc de propriétés en paramètre à des mixins. Ce qui est super\npratique lorsque l'on écrit pas mal de media queries.\n(Après, venez pas me dire qu'on a plein de fois les media-queries qui se\nrépètent et que ce n'est pas bien pour la taille du fichier, gzip se chargera de ça -\n<small>[exemple similaire](https://twitter.com/kaelig/status/412909849207644160))</small>.\n\nLe langage Sass possède une implémentation d'origine en Ruby mais aussi depuis\nquelques temps une implémentation C qui se veut beaucoup plus rapide et portable:\n[libsass](http://libsass.org/) mais qui est encore un peu en retard niveau\nfonctionnalité (affaire à suivre). Surtout depuis la version 3.3 qui possède de\nnouvelles fonctionnalités (comme les maps, entre autres).\n\nAvec ce pré-processeur, on peut s'éloigner pas mal du CSS natif, que ce soit avec\nla syntaxe ou l'aspect programmation (il n'y a qu'à voir des trucs comme\n[modular-scale](https://github.com/Team-Sass/modular-scale) ou\n[SassyMatrix](https://github.com/HugoGiraudel/SassyMatrix)).\n\nBibliotèques construites sur Sass :\n- [Compass](http://compass-style.org/), solide, basé sur Ruby (incompatible libsass),\n- [Bourbon](http://bourbon.io/), plus light mais plus rapide.\n\n### [LESS](http://lesscss.org/)\n\nJe n'ai pas trop envie de parler de ce pré-processeur assez classique, qui a fait un\nchoix assez étrange pour les variables par exemple (oui, `@` est un caractère\nspécial en CSS, c'est assez étrange de rajouter une couche avec pour les variables\navec ce dernier).\nJ'espère seulement que ceux qui l'utilisent aujourd'hui n'utilise pas le script côté client\n(ce qui provoquerait un affichage sans CSS si le client n'a pas JavaScript activé).\nBien qu'il soit populaire, le repository sur GitHub n'est pas signe de bonne santé\nà mes yeux. Voir des pull-requests qui traînent vielles de plusieurs\n<del>mois</del> <ins>années</ins> me laissent dubitatif...\nPuis il n'y a qu'à voir l'exemple sur la homepage du site avec les box-shadow,\npour voir que ce pré-processeur est assez déprécié.\n\nAjoutons à cela le fait que Twitter Boostrap a (enfin) une version Sass...\n\nCôté fonctionnalités, l'aspect programmation est assez laborieux avec la façon dont\nsont gérés les mixins conditionnels. Je passe sur ce point gerbant.\n\nBibliotèques construites sur Less :\n- [LESS Hat](http://lesshat.madebysource.com/),\n- [LESS Elements](http://www.lesselements.com/).\n\n### [Stylus](http://learnboost.github.io/stylus/)\n\nStylus se veut plus transparent que les autres pré-processeurs. C'est un point\nréussi puisqu'il permet d'avoir des mixins transparents au niveau écriture.\nCela peut par contre bien entendu rendre la maintenance et la compréhension plus\ndifficile si on en abuse.\nIl permet aussi de coder sans `{}` ni `:` ni `;` (bien que tout cela soit optionnel)\n\nNiveau fonctionnalités cela ne vaut pas Sass. Ici pas de `@content` ou de maps.\n\nBibliotèque construite sur Stylus :\n- [Nib](http://visionmedia.github.io/nib/)\n\n### Alternatives\n\nOn peut s'amuser à faire un pré-processeur CSS avec n'importe quel langage c'est\névident.\nMais [les enfants, ne faites pas ça.](http://www.alsacreations.com/astuce/lire/1433-utiliser-php-pour-gerer-vos-styles-css.html)\nÀ moins que vous souhaitiez alourdir vos CSS plus que vous y gagnerez.\nPuis si c'est juste pour ajouter des variables, il existe d'autres solutions...\n\n_Note: si vous avez d'autres pré-processeurs intéressants, je me ferais un plaisir\nde les ajouter ici. Mais bon [vous pouvez aussi le faire tout seul comme un\ngrand](https://github.com/putaindecode/putaindecode.fr/blob/master/pages/posts/css/le-point-sur-les-preprocesseurs/index.md)._\n\n## Les pré-processeurs sont-ils vraiment nécessaire ?\n\n> Oula. Le mec vient de nous poser un post pour nous parler des pré-processeurs,\net il nous sort une question comme ça ? Il est où le piège ?\n\nSi je pose la question c'est que j'ai une petite réponse par là. Et elle ne va\npeut-être pas vous plaire.\n\nJe vais revenir sur certains points qui peuvent poser problème avec les pré-processeurs.\n\n### Le nesting cay mal\n\nAhh... Le nesting, c'est bien pratique lorsque l'on travaille sur un CMS\n(ou n'importe quoi ayant un code HTML qu'on ne maitrise pas facilement)\nde pouvoir utiliser le nesting pour pouvoir rapidement produire les sélecteurs adéquats.\nMais en terme de maintenance et surtout de réutilisation, c'est vraiment à chier.\nFaut dire ce qui est.\n\n```scss\n.widget {\n  // titre\n  h3 { }\n\n  // widget body\n  > div {\n\n    // liste\n    ul {\n\n    }\n  }\n}\n```\n\nCet exemple est parfait pour démontrer les limites du nesting.\nComment faire si, sur un widget donnée, nous avons comme titre un h2 ou h4 ?\nIl faut alourdir la CSS. Pareillement, si notre fameuse liste dans le corps n'est\npas dans la même arborescence que celle décrite, il faut à nouveau alourdir notre CSS.\nSans rentrer dans ces solutions solides (nous parlerons de BEM très bientôt),\ncette solution serait bien plus élégante pour la réutilisation :\n\n```css\n.widget {}\n\n  .widget-title { }\n\n  .widget-body { }\n\n    .widget-body-list { }\n```\n\nVous remarquerez que j'ai un code ici beaucoup plus compréhensible par un nouveau,\nmais aussi bien mieux réutilisable et surtout, point très important, non couplé\n(non dépendant) à notre arborescence HTML (coucou le DOM).\nDe plus, utiliser le nesting provoque des sélecteurs à rallonges, après c'est la\ncourse à la longueur (et au poids) des sélecteurs quand il faut surcharger une\nrègle héritée.\nAvec de simple sélecteurs, pas de souci de ce genre là.\n\n_ProTip™ : vous remarquerez que j'indente mon CSS à l'image des composants, ça mange\npas de pain, est cela facilite la lecture, moins linéaire._\n\nDonc je reviens sur ce que je disais, il faut utiliser pleins de classes dans l'HTML.\nÇa sert à ça. Votre CSS produit de cette façon sera bien plus réutilisable.\n\n### L'abstraction cay dangereux\n\nOn en revient à la magie. Lorsqu'on a trop de couche qui cache ce qu'il y a\nréellement sous le capot, [on peut vite perdre le contrôle](http://linuxfr.org/news/encore-un-exemple-de-code-spaghetti-toyota).\n\nEt voici [un parfait exemple](https://github.com/MoOx/compass-recipes/issues/104)\noù un utilisateur de ma bibliothèque [Compass Recipes](https://github.com/MoOx/compass-recipes)\navait un problème lorsqu'il utilisait 2 mixins qui cachaient trop de code.\nDans  notre cas corners-tucked (version coin scotché) et background-noise (bruit visuel).\nIl en a perdu des choses simples et avait passé beaucoup de temps à se prendre la tête\nalors que la solution était très (trop) simple (une histoire entre `background-image`\net le shorthand `background`).\n\nJe me laisse souvent attirer par la magie d'un code, mais mon expérience m'indique\naujourd'hui qu'il ne faut pas abuser de cette partie mystérieuse où l'on ne sait\nplus ce qui se passe.\n\nJe vous laisse imaginer du nesting caché dans des mixins qui utilisent d'autres mixins\nqui font des @extends de placeholders...\n\n> Un grand pouvoir implique de grandes responsabilités.\n\nTout est dit. Il faut faire attention. Très attention.\n\n## Mon avis sur les pré-processeurs\n\nJe pense que les pré-processeurs restent utiles mais seulement pour des projets\nde très grosse envergure, qui possède énormément de code CSS et/ou extrêmement dynamique.\nOu que vous utilisez de solutions comme [Bootstrap](http://getbootstrap.com/) ou\n[Foundation](http://foundation.zurb.com/), chose que je déconseille pour autre chose que des prototypes.\n\nDe part mon expérience et mon recul (si si j'en prends je vous jure), je pense que\nj'aurais pu m'en passer bien plus souvent que j'ai voulu l'admettre par le passé.\nMais bon comme je dis souvent, quel plaisir de se planter quand ce n'est pas dans un platane !\n\nCe qu'il faut retenir clairement c'est que ce ne sont pas les pré-processeurs qui\nvont vous faire écrire des meilleurs feuilles de styles. C'est plus un travail sur\nune méthodologie et  une organisation adaptées à vos besoins qui amélioreront\nvotre quotidien de webdesigner (oui quoi, dès qu'on code du CSS, on peut\nutiliser l'appellation webdesigner sur son CV, ça en jette).\n\nJ'ai donc longtemps apprécié les pré-processeurs CSS, mais aujourd'hui je commence\nà leur tourner le dos du fait que je n'utilise que trop peu de leurs fonctionnalités.\nJ'évite l'overkill quoi.\n\nQuand on voit que des _grands_ de l'HTML / CSS comme [@necolas](http://nicolasgallagher.com/)\nn'utilise pas de pré-processeur, on a de quoi se poser des questions.\nAvec une bonne bibliothèque comme [SUIT CSS](https://github.com/suitcss/suit/),\non s'en retrouve à ne manquer que des petites choses.\n\nQue l'on peut combler.\n\nAvec les post-processeurs par exemple.\n\nJ'ai donc à ce jour moi aussi conservé une couche pour ajouter le minimum vital en tant que développeur.\n\nMais ne voulant pas alourdir ce post consacré aux pré-processeurs CSS,\nvous pourrez continuer la lecture au prochain épisode qui sera consacré aux post-processeurs...\n\n<small>(Mamam, t'as vu ce cliffhanger digne des séries US !)</small>\n\n~~Bon promis la prochaine fois je vous en parle des post-processeurs. Pour de vrai.~~\nChose promise, chose due : [Les post-processeurs CSS](/posts/css/les-post-processeurs/)\n","raw":"---\ndate: \"2014-03-11\"\ntitle: Le point sur les pré-processeurs CSS\ntags:\n  - css\n  - pré-processeur\n  - post-processeur\nauthors:\n  - MoOx\n---\n\n## Pourquoi les pré-processeurs\n\nVoilà ce que j'ai écrit en 2011 dans\n[mon premier post sur les pré-processeur](http://moox.io/blog/utiliser-des-variables-fonctions-css/).\nJe venais de découvrir cette notion et j'avais donc fait le tour de la question.\n\n> Le langage des CSS n’a pas de côté dynamique. C’est lui avec lequel, à chaque\nfois qu’on intègre une maquette graphique, on doit se taper tout de zéro.\nIl a beau exister des CSS « Reset », des frameworks CSS, tout un tas de\ngrilles prête à l’emploi, des composants de CSS réutilisables avec l’approche\nobjet, je n’ai jamais réellement été satisfait par ces méthodes, que ce soit\nà cause des contraintes qu’impose la syntaxe (devoir mettre des classes à tout\nva dans l’HTML ça peut vite devenir chiant dans un CMS), ou par d’éventuelles\nlimitations qui obligent à « trop » modifier la source du document (pas assez\nde, ou trop de, ou seulement ça ne me plait pas comment c’est fait).\n\nJ'avais tout dit, même des trucs qu'aujourd'hui je pense être des conneries (il\nn'y a que les cons qui ne changent pas d'avis + c'est en faisant des erreurs\nqu'on apprend le mieux), mais je reviendrais dessus plus tard.\n\nDu coup on en retire quoi ? Qu'utiliser un pré-processeur se justifie par\nl'ajout de fonctionnalités lorsque vous écrivez des feuilles de style (en tant\nque développeur). En tant qu'utilisateur du code produit, cela va permettre\nd'ajouter une couche abstraction (ce qui peut poser des problèmes, je reviendrais\nsur ce point plus tard).\n\n## Principales fonctionnalités\n\n  - variables\n  - fonctions\n  - mixins (permettant de réaliser des sorties CSS paramétrables)\n  - `@import` intelligent (pas côté client)\n  - nesting (imbrications des sélecteurs pour éviter la répétition)\n  - optimisation et abstraction poussée (via les mixins, placeholders et `@extend`)\n\nAnciennement on aurait rajouté à cette liste la gestion du CSS 3, mais comme\nje l'expliquais il y a peu, ce n'est plus nécessaire, on a une méthode bien\nmieux, rapide et surtout <b>maintenu à jour</b> avec\n[AutoPrefixer](/posts/css/comment-en-finir-avec-les-prefixes/)\n\n## Les principaux pré-processeurs\n\n### [Sass](http://sass-lang.com/)\n\nSass est à mon avis le plus mature des pré-processeurs CSS.\nIl possède 2 syntaxes (une indentée et une plus proche de CSS).\nCe projet avance à bon rythme. Niveau fonctionnalités, rien à dire si ce n'est que\ncelui-ci a un petit plus pour avec la feature `@content` qui permet pour le coup de\npasser tout un bloc de propriétés en paramètre à des mixins. Ce qui est super\npratique lorsque l'on écrit pas mal de media queries.\n(Après, venez pas me dire qu'on a plein de fois les media-queries qui se\nrépètent et que ce n'est pas bien pour la taille du fichier, gzip se chargera de ça -\n<small>[exemple similaire](https://twitter.com/kaelig/status/412909849207644160))</small>.\n\nLe langage Sass possède une implémentation d'origine en Ruby mais aussi depuis\nquelques temps une implémentation C qui se veut beaucoup plus rapide et portable:\n[libsass](http://libsass.org/) mais qui est encore un peu en retard niveau\nfonctionnalité (affaire à suivre). Surtout depuis la version 3.3 qui possède de\nnouvelles fonctionnalités (comme les maps, entre autres).\n\nAvec ce pré-processeur, on peut s'éloigner pas mal du CSS natif, que ce soit avec\nla syntaxe ou l'aspect programmation (il n'y a qu'à voir des trucs comme\n[modular-scale](https://github.com/Team-Sass/modular-scale) ou\n[SassyMatrix](https://github.com/HugoGiraudel/SassyMatrix)).\n\nBibliotèques construites sur Sass :\n- [Compass](http://compass-style.org/), solide, basé sur Ruby (incompatible libsass),\n- [Bourbon](http://bourbon.io/), plus light mais plus rapide.\n\n### [LESS](http://lesscss.org/)\n\nJe n'ai pas trop envie de parler de ce pré-processeur assez classique, qui a fait un\nchoix assez étrange pour les variables par exemple (oui, `@` est un caractère\nspécial en CSS, c'est assez étrange de rajouter une couche avec pour les variables\navec ce dernier).\nJ'espère seulement que ceux qui l'utilisent aujourd'hui n'utilise pas le script côté client\n(ce qui provoquerait un affichage sans CSS si le client n'a pas JavaScript activé).\nBien qu'il soit populaire, le repository sur GitHub n'est pas signe de bonne santé\nà mes yeux. Voir des pull-requests qui traînent vielles de plusieurs\n<del>mois</del> <ins>années</ins> me laissent dubitatif...\nPuis il n'y a qu'à voir l'exemple sur la homepage du site avec les box-shadow,\npour voir que ce pré-processeur est assez déprécié.\n\nAjoutons à cela le fait que Twitter Boostrap a (enfin) une version Sass...\n\nCôté fonctionnalités, l'aspect programmation est assez laborieux avec la façon dont\nsont gérés les mixins conditionnels. Je passe sur ce point gerbant.\n\nBibliotèques construites sur Less :\n- [LESS Hat](http://lesshat.madebysource.com/),\n- [LESS Elements](http://www.lesselements.com/).\n\n### [Stylus](http://learnboost.github.io/stylus/)\n\nStylus se veut plus transparent que les autres pré-processeurs. C'est un point\nréussi puisqu'il permet d'avoir des mixins transparents au niveau écriture.\nCela peut par contre bien entendu rendre la maintenance et la compréhension plus\ndifficile si on en abuse.\nIl permet aussi de coder sans `{}` ni `:` ni `;` (bien que tout cela soit optionnel)\n\nNiveau fonctionnalités cela ne vaut pas Sass. Ici pas de `@content` ou de maps.\n\nBibliotèque construite sur Stylus :\n- [Nib](http://visionmedia.github.io/nib/)\n\n### Alternatives\n\nOn peut s'amuser à faire un pré-processeur CSS avec n'importe quel langage c'est\névident.\nMais [les enfants, ne faites pas ça.](http://www.alsacreations.com/astuce/lire/1433-utiliser-php-pour-gerer-vos-styles-css.html)\nÀ moins que vous souhaitiez alourdir vos CSS plus que vous y gagnerez.\nPuis si c'est juste pour ajouter des variables, il existe d'autres solutions...\n\n_Note: si vous avez d'autres pré-processeurs intéressants, je me ferais un plaisir\nde les ajouter ici. Mais bon [vous pouvez aussi le faire tout seul comme un\ngrand](https://github.com/putaindecode/putaindecode.fr/blob/master/pages/posts/css/le-point-sur-les-preprocesseurs/index.md)._\n\n## Les pré-processeurs sont-ils vraiment nécessaire ?\n\n> Oula. Le mec vient de nous poser un post pour nous parler des pré-processeurs,\net il nous sort une question comme ça ? Il est où le piège ?\n\nSi je pose la question c'est que j'ai une petite réponse par là. Et elle ne va\npeut-être pas vous plaire.\n\nJe vais revenir sur certains points qui peuvent poser problème avec les pré-processeurs.\n\n### Le nesting cay mal\n\nAhh... Le nesting, c'est bien pratique lorsque l'on travaille sur un CMS\n(ou n'importe quoi ayant un code HTML qu'on ne maitrise pas facilement)\nde pouvoir utiliser le nesting pour pouvoir rapidement produire les sélecteurs adéquats.\nMais en terme de maintenance et surtout de réutilisation, c'est vraiment à chier.\nFaut dire ce qui est.\n\n```scss\n.widget {\n  // titre\n  h3 { }\n\n  // widget body\n  > div {\n\n    // liste\n    ul {\n\n    }\n  }\n}\n```\n\nCet exemple est parfait pour démontrer les limites du nesting.\nComment faire si, sur un widget donnée, nous avons comme titre un h2 ou h4 ?\nIl faut alourdir la CSS. Pareillement, si notre fameuse liste dans le corps n'est\npas dans la même arborescence que celle décrite, il faut à nouveau alourdir notre CSS.\nSans rentrer dans ces solutions solides (nous parlerons de BEM très bientôt),\ncette solution serait bien plus élégante pour la réutilisation :\n\n```css\n.widget {}\n\n  .widget-title { }\n\n  .widget-body { }\n\n    .widget-body-list { }\n```\n\nVous remarquerez que j'ai un code ici beaucoup plus compréhensible par un nouveau,\nmais aussi bien mieux réutilisable et surtout, point très important, non couplé\n(non dépendant) à notre arborescence HTML (coucou le DOM).\nDe plus, utiliser le nesting provoque des sélecteurs à rallonges, après c'est la\ncourse à la longueur (et au poids) des sélecteurs quand il faut surcharger une\nrègle héritée.\nAvec de simple sélecteurs, pas de souci de ce genre là.\n\n_ProTip™ : vous remarquerez que j'indente mon CSS à l'image des composants, ça mange\npas de pain, est cela facilite la lecture, moins linéaire._\n\nDonc je reviens sur ce que je disais, il faut utiliser pleins de classes dans l'HTML.\nÇa sert à ça. Votre CSS produit de cette façon sera bien plus réutilisable.\n\n### L'abstraction cay dangereux\n\nOn en revient à la magie. Lorsqu'on a trop de couche qui cache ce qu'il y a\nréellement sous le capot, [on peut vite perdre le contrôle](http://linuxfr.org/news/encore-un-exemple-de-code-spaghetti-toyota).\n\nEt voici [un parfait exemple](https://github.com/MoOx/compass-recipes/issues/104)\noù un utilisateur de ma bibliothèque [Compass Recipes](https://github.com/MoOx/compass-recipes)\navait un problème lorsqu'il utilisait 2 mixins qui cachaient trop de code.\nDans  notre cas corners-tucked (version coin scotché) et background-noise (bruit visuel).\nIl en a perdu des choses simples et avait passé beaucoup de temps à se prendre la tête\nalors que la solution était très (trop) simple (une histoire entre `background-image`\net le shorthand `background`).\n\nJe me laisse souvent attirer par la magie d'un code, mais mon expérience m'indique\naujourd'hui qu'il ne faut pas abuser de cette partie mystérieuse où l'on ne sait\nplus ce qui se passe.\n\nJe vous laisse imaginer du nesting caché dans des mixins qui utilisent d'autres mixins\nqui font des @extends de placeholders...\n\n> Un grand pouvoir implique de grandes responsabilités.\n\nTout est dit. Il faut faire attention. Très attention.\n\n## Mon avis sur les pré-processeurs\n\nJe pense que les pré-processeurs restent utiles mais seulement pour des projets\nde très grosse envergure, qui possède énormément de code CSS et/ou extrêmement dynamique.\nOu que vous utilisez de solutions comme [Bootstrap](http://getbootstrap.com/) ou\n[Foundation](http://foundation.zurb.com/), chose que je déconseille pour autre chose que des prototypes.\n\nDe part mon expérience et mon recul (si si j'en prends je vous jure), je pense que\nj'aurais pu m'en passer bien plus souvent que j'ai voulu l'admettre par le passé.\nMais bon comme je dis souvent, quel plaisir de se planter quand ce n'est pas dans un platane !\n\nCe qu'il faut retenir clairement c'est que ce ne sont pas les pré-processeurs qui\nvont vous faire écrire des meilleurs feuilles de styles. C'est plus un travail sur\nune méthodologie et  une organisation adaptées à vos besoins qui amélioreront\nvotre quotidien de webdesigner (oui quoi, dès qu'on code du CSS, on peut\nutiliser l'appellation webdesigner sur son CV, ça en jette).\n\nJ'ai donc longtemps apprécié les pré-processeurs CSS, mais aujourd'hui je commence\nà leur tourner le dos du fait que je n'utilise que trop peu de leurs fonctionnalités.\nJ'évite l'overkill quoi.\n\nQuand on voit que des _grands_ de l'HTML / CSS comme [@necolas](http://nicolasgallagher.com/)\nn'utilise pas de pré-processeur, on a de quoi se poser des questions.\nAvec une bonne bibliothèque comme [SUIT CSS](https://github.com/suitcss/suit/),\non s'en retrouve à ne manquer que des petites choses.\n\nQue l'on peut combler.\n\nAvec les post-processeurs par exemple.\n\nJ'ai donc à ce jour moi aussi conservé une couche pour ajouter le minimum vital en tant que développeur.\n\nMais ne voulant pas alourdir ce post consacré aux pré-processeurs CSS,\nvous pourrez continuer la lecture au prochain épisode qui sera consacré aux post-processeurs...\n\n<small>(Mamam, t'as vu ce cliffhanger digne des séries US !)</small>\n\n~~Bon promis la prochaine fois je vous en parle des post-processeurs. Pour de vrai.~~\nChose promise, chose due : [Les post-processeurs CSS](/posts/css/les-post-processeurs/)\n","__filename":"posts/css/le-point-sur-les-preprocesseurs/index.md","__url":"/posts/css/le-point-sur-les-preprocesseurs/"}