{"head":{"layout":"Post","comments":true,"date":"2014-11-03","title":"Laissez-vous pousser la barbe, apprenez à écrire des Makefiles","tags":["shell","makefile"],"authors":["madx"]},"body":"<p>À l’heure où tout le monde se rue sur des outils comme <a href=\"/posts/js/introduction-gulp/\">Gulp</a>,\n<a href=\"/posts/js/premiers-pas-avec-grunt/\">Grunt</a> ou autres <a href=\"https://rubygems.org/gems/rake\">Rake</a>, certains irréductibles (dont je\nfais partie) ont fait le choix d’employer un des outils les plus standards et\nemblématiques dont tout développeur a entendu parler au moins une fois dans sa\nvie : <em>Make</em>.</p>\n<p>Si de prime abord on a l’impression d’un système assez archaïque (ce qui n’est\npas toujours forcément faux), on se rend rapidement compte que <em>Make</em>, couplé à\nune petite dose de scripting shell permet rapidement de mettre en place un moyen\nde compiler ses fichiers et de lancer des tâches.</p>\n<p>Les fichiers de configuration de <em>Make</em> sont appellés <em>Makefiles</em> (oui, ce sont\neux qui ont donné leurs noms aux <code>(Gulp|Grunt|Rake)files</code>). Les instructions\nqu’ils contiennent sont exécutées grâce à la commande <code>make</code> dans votre\nterminal.</p>\n<h1 id=\"hello-world\"><a class=\"markdownIt-Anchor\" href=\"#hello-world\">#</a> Hello World</h1>\n<p>Je vous propose de commencer en douceur par un classique <em>Hello World</em>. On va\nsimplement définir une tâche <code>hello-world</code> dont l’action va être d’afficher\n<em>“Hello, world”</em> à l’écran (boooring).</p>\n<pre><code class=\"language-make\">hello-world:\n\t<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"Hello, world\"</span></code></pre>\n<p>Première remarque importante, les indentations dans un <em>Makefile</em> <strong>doivent</strong>\nêtre faites avec des tabulations. Oui, je sais, c’est moche, on dirait du\nPython, mais c’est comme ça.</p>\n<p>Voilà le genre d’erreurs qu’on se prend si on met des espaces à la place des\ntabulations :</p>\n<pre><code>Makefile:2: <span class=\"hljs-keyword\">*</span><span class=\"hljs-keyword\">*</span><span class=\"hljs-keyword\">*</span> séparateur manquant . Arrêt.</code></pre>\n<p>Pour exécuter notre commande, il nous suffit de lancer <code>make hello-world</code> dans\nun terminal :</p>\n<pre><code class=\"language-console\">$ <span class=\"hljs-keyword\">make</span> hello-world\n<span class=\"hljs-keyword\">echo</span> <span class=\"hljs-string\">\"Hello, world\"</span>\nHello, world</code></pre>\n<p>Décortiquons un peu cette exécution. Pour chaque commande qu’il exécute, <em>Make</em>\naffiche la commande complète avant d’afficher la sortie standard de ladite\ncommande. C’est souvent très pratique car toutes les variables (on va revenir là dessus)\nqu’on met dans la commande sont résolues, et on voit clairement ce que <em>Make</em>\nexécute. Par contre, dans certains cas on s’en fout un peu, on peut alors\npréfixer la ligne à rendre silencieuse par un <code>@</code>, comme ça :</p>\n<pre><code class=\"language-make\">hello-world:\n\t@ <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"Hello, world\"</span></code></pre>\n<pre><code class=\"language-console\"><span class=\"hljs-variable\">$ </span>make hello-world\n<span class=\"hljs-constant\">Hello</span>, world</code></pre>\n<h1 id=\"r-gles-cibles-recettes-et-pr-requis\"><a class=\"markdownIt-Anchor\" href=\"#r-gles-cibles-recettes-et-pr-requis\">#</a> Règles, cibles, recettes et pré-requis</h1>\n<p>OK, jusque là c’est génial, on a un super outil pour lancer des commandes qu’on\npourrait déjà stocker dans un bête script shell. Pas super utile finalement.</p>\n<p>Bon, on va corser un peu les choses et commencer par définir un peu de\nterminologie avant que vous soyez totalement largués.</p>\n<p>Un <em>Makefile</em> est une collection de <strong>règles</strong>, chacune étant composée d’une\n<strong>cible</strong>, de <strong>pré-requis</strong> (ou pas) et d’une <strong>recette</strong>. Dans notre exemple\nprécédent, <code>hello-world</code> est la cible et <code>@ echo &quot;Hello, world&quot;</code> est la recette\nde la règle. Elle ne spécifie par contre pas de pré-requis.</p>\n<p>Relisez trois ou quatre fois le paragraphe précédent jusqu’à ce que ce soit bien\nimprimé.</p>\n<p>Vous l’aurez compris, on invoque une règle depuis la ligne de commande en\nspécifiant le nom de sa cible après la commande <code>make</code>. Si on ne précise rien,\nc’est la première règle trouvée qui est exécutée (donc dans notre cas,\n<code>hello-world</code>).</p>\n<p>Les pré-requis sont déclarés après la cible. On pourrait par exemple ajouter un\n<code>sauter-une-ligne</code> comme pré-requis à notre cible <code>hello-world</code> :</p>\n<pre><code class=\"language-make\">hello-world: sauter-une-ligne\n\t@ <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"Hello, world\"</span>\n\nsauter-une-ligne:\n\t@ <span class=\"hljs-built_in\">echo</span></code></pre>\n<pre><code class=\"language-console\"><span class=\"hljs-variable\">$ </span>make hello-world\n\n<span class=\"hljs-constant\">Hello</span>, world</code></pre>\n<p>Facile, non ? Ok alors on peut <em>vraiment</em> attaquer les choses sérieuses.</p>\n<h1 id=\"construire-des-fichiers\"><a class=\"markdownIt-Anchor\" href=\"#construire-des-fichiers\">#</a> Construire des fichiers</h1>\n<p>Les pré-requis sont particulièrement pratiques quand on veut construire un\nfichier depuis un autre, ce qui est la principale action d’à peu près tout\nprocessus de compilation (paraît même que c’est grosso modo la définition de la\ncompilation).</p>\n<p>On peut par exemple écrire un <em>Makefile</em> nous permettant de compiler un fichier\n<em>Markdown</em> en <em>HTML</em> :</p>\n<pre><code class=\"language-make\"><span class=\"hljs-tag\">article</span><span class=\"hljs-class\">.html</span>: <span class=\"hljs-tag\">article</span><span class=\"hljs-class\">.md</span>\n\tmarked <span class=\"hljs-tag\">article</span><span class=\"hljs-class\">.md</span> &gt; <span class=\"hljs-tag\">article</span>.html</code></pre>\n<p>Cette règle spécifie simplement que pour construire le fichier <code>article.html</code>\nj’ai besoin du fichier <code>article.md</code> et que j’utilise la commande\n<a href=\"https://www.npmjs.org/package/marked\"><code>marked</code></a> pour construire le fichier. Essayez, vous verrez, c’est\nmagique.</p>\n<p>Là où ça devient intéressant, c’est que si je lance de nouveau <code>make article.html</code>, rien ne se passe. Eh oui, <em>Make</em> vérifie les dates de\nmodification des pré-requis et les compare avec la date de modification de la\ncible pour savoir s’il doit où non reconstruire la cible.</p>\n<p>On peut bien sûr aller plus loin en ayant des fichiers qui dépendent de\nfichiers, qui à leur tour dépendent de fichiers, …</p>\n<p><a name=\"ref-phony-target\"></a></p>\n<p>On peut aussi avoir une cible factice qui ne représente pas un fichier et qui\nelle-même dépend de plusieurs fichiers (<code>website: index.html apropos.html contact.html</code>).</p>\n<h1 id=\"variables-et-substitutions\"><a class=\"markdownIt-Anchor\" href=\"#variables-et-substitutions\">#</a> Variables et substitutions</h1>\n<p>La syntaxe des variables dans un <em>Makefile</em> ressemblent beaucoup aux variables\nde votre Shell, <em>mais pas tout à fait</em>.</p>\n<pre><code class=\"language-make\">SOURCE = <span class=\"hljs-keyword\">index</span>.md\nDESTINATION = <span class=\"hljs-keyword\">index</span>.html\n\n<span class=\"hljs-variable\">${DESTINATION}</span>: <span class=\"hljs-variable\">${SOURCE}</span>\n  marked <span class=\"hljs-variable\">${SOURCE}</span> &gt; <span class=\"hljs-variable\">${DESTINATION}</span></code></pre>\n<p>On peut aussi utiliser une substitution pour s’éviter de tout retaper. La\nsyntaxe pour ça est assez simple et se passe d’explications :</p>\n<pre><code class=\"language-make\"><span class=\"hljs-setting\">SOURCE = <span class=\"hljs-value\">index.md</span></span>\n<span class=\"hljs-setting\">DESTINATION = <span class=\"hljs-value\"><span class=\"hljs-variable\">${SOURCE:.md=.html}</span></span></span></code></pre>\n<p>Là où ça devient beaucoup plus intéressant c’est qu’on peut stocker des listes\ndans une variable. Pour ça, pas vraiment d’effort à faire, il suffit de rajouter\ndes noms à la suite :</p>\n<pre><code class=\"language-make\">SOURCE = index.<span class=\"hljs-built_in\">md</span> article.<span class=\"hljs-built_in\">md</span>\nDESTINATION = ${SOURCE:.<span class=\"hljs-built_in\">md</span>=.html}</code></pre>\n<p>Attention par contre ! En faisant ça si vous utilisez <code>${SOURCE}</code> comme cible\nd’une règle, vous allez définir plusieurs règles d’un coup, ce qui n’est peut\nêtre pas ce que vous voulez.</p>\n<p>On peut contourner ça assez simplement en utilisant une substitution au niveau\nde la règle. La syntaxe est un poil différente :</p>\n<pre><code class=\"language-make\">%<span class=\"hljs-class\">.html</span>: %<span class=\"hljs-class\">.md</span>\n  <span class=\"hljs-attr_selector\">[...]</span></code></pre>\n<p>Vous l’aurez compris, <code>%</code> est identique dans la cible et dans la dépendance,\ndonc avec cette règle si vous faites un <code>make index.html</code>, <em>Make</em> va tenter de\nconstruire la dépendance <code>index.md</code> avant tout.</p>\n<p>Un problème se pose à nous avec cette syntaxe : « Bah merde, comment je récupère\nles noms de fichiers là ? »</p>\n<h1 id=\"variables-sp-ciales\"><a class=\"markdownIt-Anchor\" href=\"#variables-sp-ciales\">#</a> Variables spéciales</h1>\n<p>Superbe transition étant donné qu’on va parler ici de quelques variables\nspéciales bien pratiques !</p>\n<ul>\n<li><code>$@</code> contient le nom de la cible de la règle en cours d’exécution ;</li>\n<li><code>$^</code> contient la liste des dépendances de la règle (la flèche pointe vers la\nliste de dépendances) ;</li>\n<li><code>$&lt;</code> contient la première dépendance de la règle (la flèche pointe à gauche,\nlà où est la dépendance).</li>\n</ul>\n<p>À l’aide de celles-ci on peut du coup compléter notre exemple précédent :</p>\n<pre><code class=\"language-make\"><span class=\"hljs-variable\">%.</span>html: <span class=\"hljs-variable\">%.</span>md\n  marked <span class=\"hljs-variable\">$&lt;</span> &gt; <span class=\"hljs-variable\">$@</span>\n  [...]</code></pre>\n<h1 id=\"fonctions\"><a class=\"markdownIt-Anchor\" href=\"#fonctions\">#</a> Fonctions</h1>\n<p>Pour faciliter quelques opérations, <em>Make</em> fournit un ensemble de fonctions de\nbase. Appeler ces fonctions rappelle un peu la façon dont on lance une commande\ndans un sous-shell en Bash : <code>$(fonction argument1 argument2)</code>.</p>\n<p>Voici une petite démonstration de <code>wildcard</code>, <code>addsuffix</code> et <code>basename</code> dont\nvous vous doutez sans doute les effets :</p>\n<pre><code class=\"language-make\">SOURCES = <span class=\"hljs-variable\">$(</span>wildcard <span class=\"hljs-variable\">*.</span>md)\nDESTINATIONS = <span class=\"hljs-variable\">$(</span>addsuffix .html,<span class=\"hljs-variable\">$(</span><span class=\"hljs-keyword\">basename</span> <span class=\"hljs-variable\">${SOURCES}</span>))\n\nall: <span class=\"hljs-variable\">${DESTINATIONS}</span>\n\n<span class=\"hljs-variable\">%.</span>html: <span class=\"hljs-variable\">%.</span>md\n  marked <span class=\"hljs-variable\">$&lt;</span> &gt; <span class=\"hljs-variable\">$@</span></code></pre>\n<p>L’exemple construit dynamiquement la liste des fichiers HTML à produire à partir\nde la liste des fichiers <em>Markdown</em> disponibles puis définit une règle <code>all</code>\npermettant de tout construire d’un coup, et une règle définissant compiler\nunitairement un fichier <em>Markdown</em> vers HTML.</p>\n<p>Vous noterez qu’<code>addsuffix</code>/<code>basename</code> peut être remplacé par une substitution\nsimple comme on a vu précédemment.</p>\n<p>Je vous invite à fouiller\n<a href=\"https://www.gnu.org/software/make/manual/make.html#Functions\">le chapitre sur les fonctions du manuel</a>.</p>\n<h1 id=\"la-cible-phony\"><a class=\"markdownIt-Anchor\" href=\"#la-cible-phony\">#</a> La cible <code>.PHONY</code></h1>\n<p>Dans certains cas la cible d’une règle ne représente pas un fichier (c’était le\ncas de notre cible <code>website</code> <a href=\"#ref-phony-target\">un peu plus haut</a>).</p>\n<p>Dans ces cas-là, on va vouloir exécuter la règle quoi qu’il arrive, comme si la\ncible était tout le temps périmée.</p>\n<p>Une cible particulière existe pour ça : <code>.PHONY</code>. Toutes les dépendances de\ncette cible seront marquées comme (traduction pourrie) imposteurs (<em>phony</em>\ndonc).</p>\n<p>Pour reprendre l’exemple précédent, on déclarera donc :</p>\n<pre><code class=\"language-make\"><span class=\"hljs-class\">.PHONY</span>: website\n\nwebsite: index<span class=\"hljs-class\">.html</span> apropos<span class=\"hljs-class\">.html</span> contact<span class=\"hljs-class\">.html</span>\n  [...]</code></pre>\n<p>Désormais, chaque appel à <code>make website</code> tentera de construire les dépendances\net exécutera les commandes de la recette de la règle.</p>\n<h1 id=\"un-exemple-complet\"><a class=\"markdownIt-Anchor\" href=\"#un-exemple-complet\">#</a> Un exemple complet</h1>\n<p>L’exemple suivant permet de compiler un site Web depuis un ensemble de fichiers\n<em>Markdown</em>.</p>\n<pre><code class=\"language-make\"><span class=\"hljs-constant\">SOURCES</span> = <span class=\"hljs-variable\">$(</span>wildcard src/*.md)\n<span class=\"hljs-constant\">DESTINATIONS</span> = <span class=\"hljs-variable\">${</span><span class=\"hljs-constant\">SOURCES</span><span class=\"hljs-symbol\">:src/%</span>.md=build/%.html}\n\n<span class=\"hljs-symbol\">all:</span> <span class=\"hljs-variable\">${</span><span class=\"hljs-constant\">DESTINATIONS</span>}\n\n<span class=\"hljs-symbol\">info:</span>\n\t@ echo <span class=\"hljs-constant\">Will</span> build <span class=\"hljs-variable\">${</span><span class=\"hljs-constant\">DESTINATIONS</span>} from <span class=\"hljs-variable\">${</span><span class=\"hljs-constant\">SOURCES</span>}\n\n<span class=\"hljs-symbol\">clean:</span>\n\trm -f <span class=\"hljs-variable\">${</span><span class=\"hljs-constant\">DESTINATIONS</span>}\n\nbuild/%.<span class=\"hljs-symbol\">html:</span> src/%.md\n\tmkdir -p build\n\tmarked <span class=\"hljs-variable\">$&lt;</span> &gt; <span class=\"hljs-variable\">$@</span>\n\n.<span class=\"hljs-constant\">PHONY</span><span class=\"hljs-symbol\">:</span> all info clean</code></pre>\n<p>Vous noterez que comme on stocke nos résultats dans le dossier <code>build</code>, il faut\npotentiellement le créer quand on compile un fichier dedans.</p>\n<h1 id=\"pour-aller-plus-loin\"><a class=\"markdownIt-Anchor\" href=\"#pour-aller-plus-loin\">#</a> Pour aller plus loin</h1>\n<p>Il existe bien d’autres fonctionnalités dans <em>Make</em> (du moins dans <em>GNU Make</em>),\navec notamment :</p>\n<ul>\n<li>Les <a href=\"https://www.gnu.org/software/make/manual/make.html#Canned-Recipes\"><em>canned recipes</em></a> (recettes en boîte), permettant de\ndéfinir un bout de règle réutilisable à plusieurs endroits.</li>\n<li>Des <a href=\"https://www.gnu.org/software/make/manual/make.html#Functions\">expressions conditionnelles</a> pour avoir des tests\ndans votre <em>Makefile</em> et effectuer des traitements différents selon\nl’environnement.</li>\n<li>Les <a href=\"https://www.gnu.org/software/make/manual/make.html##Prerequisite-Types\">règles en <em>order only</em></a> qui permettent d’indiquer une\ndépendance dont la date de modification ne doit pas être prise en compte (on\npeut s’en servir pour éviter le <code>mkdir</code> dans l’exemple complet).</li>\n<li>Et <a href=\"https://www.gnu.org/software/make/manual/make.html#Functions\">plein d’autres fonctions</a> bien pratiques !</li>\n</ul>\n<p>Je vous invite aussi à jeter un coup d’œil au <a href=\"https://github.com/madx/veil/\"><em>Makefile</em> de Veil</a>, un outil que\nj’utilise pour générer des sites statiques à partir de fichiers <em>Markdown</em>\n(ah bah tiens, comme dans mes exemples, c’est rigolo). Il y a plein de\nfonctionnalités de <em>Make</em> utilisées dans ce projet et je pense que ça peut être\nsource d’idées.</p>\n<p>Voilà pour cette premier introduction à <em>Make</em>, j’espère que ça vous a plu et\nque vous êtes fin prêts à affronter tous ces bouseux avec leur système de build\nà base de streams, de brocolis et autres râteaux.</p>\n","rawBody":"\nÀ l'heure où tout le monde se rue sur des outils comme [Gulp][p!gulp],\n[Grunt][p!grunt] ou autres [Rake][gem:rake], certains irréductibles (dont je\nfais partie) ont fait le choix d'employer un des outils les plus standards et\nemblématiques dont tout développeur a entendu parler au moins une fois dans sa\nvie : *Make*.\n\nSi de prime abord on a l'impression d'un système assez archaïque (ce qui n'est\npas toujours forcément faux), on se rend rapidement compte que _Make_, couplé à\nune petite dose de scripting shell permet rapidement de mettre en place un moyen\nde compiler ses fichiers et de lancer des tâches.\n\nLes fichiers de configuration de _Make_ sont appellés _Makefiles_ (oui, ce sont\neux qui ont donné leurs noms aux `(Gulp|Grunt|Rake)files`). Les instructions\nqu'ils contiennent sont exécutées grâce à la commande `make` dans votre\nterminal.\n\n# Hello World\n\nJe vous propose de commencer en douceur par un classique _Hello World_. On va\nsimplement définir une tâche `hello-world` dont l'action va être d'afficher\n_\"Hello, world\"_ à l'écran (boooring).\n\n``` make\nhello-world:\n\techo \"Hello, world\"\n```\n\nPremière remarque importante, les indentations dans un _Makefile_ **doivent**\nêtre faites avec des tabulations. Oui, je sais, c'est moche, on dirait du\nPython, mais c'est comme ça.\n\nVoilà le genre d'erreurs qu'on se prend si on met des espaces à la place des\ntabulations :\n\n```\nMakefile:2: *** séparateur manquant . Arrêt.\n```\n\n\nPour exécuter notre commande, il nous suffit de lancer `make hello-world` dans\nun terminal :\n\n``` console\n$ make hello-world\necho \"Hello, world\"\nHello, world\n```\n\nDécortiquons un peu cette exécution. Pour chaque commande qu'il exécute, _Make_\naffiche la commande complète avant d'afficher la sortie standard de ladite\ncommande. C'est souvent très pratique car toutes les variables (on va revenir là dessus)\nqu'on met dans la commande sont résolues, et on voit clairement ce que _Make_\nexécute. Par contre, dans certains cas on s'en fout un peu, on peut alors\npréfixer la ligne à rendre silencieuse par un `@`, comme ça :\n\n``` make\nhello-world:\n\t@ echo \"Hello, world\"\n```\n\n``` console\n$ make hello-world\nHello, world\n```\n\n# Règles, cibles, recettes et pré-requis\n\nOK, jusque là c'est génial, on a un super outil pour lancer des commandes qu'on\npourrait déjà stocker dans un bête script shell. Pas super utile finalement.\n\nBon, on va corser un peu les choses et commencer par définir un peu de\nterminologie avant que vous soyez totalement largués.\n\nUn _Makefile_ est une collection de **règles**, chacune étant composée d'une\n**cible**, de **pré-requis** (ou pas) et d'une **recette**. Dans notre exemple\nprécédent, `hello-world` est la cible et `@ echo \"Hello, world\"` est la recette\nde la règle. Elle ne spécifie par contre pas de pré-requis.\n\nRelisez trois ou quatre fois le paragraphe précédent jusqu'à ce que ce soit bien\nimprimé.\n\nVous l'aurez compris, on invoque une règle depuis la ligne de commande en\nspécifiant le nom de sa cible après la commande `make`. Si on ne précise rien,\nc'est la première règle trouvée qui est exécutée (donc dans notre cas,\n`hello-world`).\n\nLes pré-requis sont déclarés après la cible. On pourrait par exemple ajouter un\n`sauter-une-ligne` comme pré-requis à notre cible `hello-world` :\n\n``` make\nhello-world: sauter-une-ligne\n\t@ echo \"Hello, world\"\n\nsauter-une-ligne:\n\t@ echo\n```\n\n``` console\n$ make hello-world\n\nHello, world\n```\n\nFacile, non ? Ok alors on peut *vraiment* attaquer les choses sérieuses.\n\n# Construire des fichiers\n\nLes pré-requis sont particulièrement pratiques quand on veut construire un\nfichier depuis un autre, ce qui est la principale action d'à peu près tout\nprocessus de compilation (paraît même que c'est grosso modo la définition de la\ncompilation).\n\nOn peut par exemple écrire un _Makefile_ nous permettant de compiler un fichier\n_Markdown_ en _HTML_ :\n\n``` make\narticle.html: article.md\n\tmarked article.md > article.html\n```\n\nCette règle spécifie simplement que pour construire le fichier `article.html`\nj'ai besoin du fichier `article.md` et que j'utilise la commande\n[`marked`][npm:marked] pour construire le fichier. Essayez, vous verrez, c'est\nmagique.\n\nLà où ça devient intéressant, c'est que si je lance de nouveau `make\narticle.html`, rien ne se passe. Eh oui, _Make_ vérifie les dates de\nmodification des pré-requis et les compare avec la date de modification de la\ncible pour savoir s'il doit où non reconstruire la cible.\n\nOn peut bien sûr aller plus loin en ayant des fichiers qui dépendent de\nfichiers, qui à leur tour dépendent de fichiers, …\n\n<a name=\"ref-phony-target\"></a>\n\nOn peut aussi avoir une cible factice qui ne représente pas un fichier et qui\nelle-même dépend de plusieurs fichiers (`website: index.html apropos.html\ncontact.html`).\n\n# Variables et substitutions\n\nLa syntaxe des variables dans un *Makefile* ressemblent beaucoup aux variables\nde votre Shell, *mais pas tout à fait*.\n\n``` make\nSOURCE = index.md\nDESTINATION = index.html\n\n${DESTINATION}: ${SOURCE}\n  marked ${SOURCE} > ${DESTINATION}\n```\n\nOn peut aussi utiliser une substitution pour s'éviter de tout retaper. La\nsyntaxe pour ça est assez simple et se passe d'explications :\n\n``` make\nSOURCE = index.md\nDESTINATION = ${SOURCE:.md=.html}\n```\n\nLà où ça devient beaucoup plus intéressant c'est qu'on peut stocker des listes\ndans une variable. Pour ça, pas vraiment d'effort à faire, il suffit de rajouter\ndes noms à la suite :\n\n``` make\nSOURCE = index.md article.md\nDESTINATION = ${SOURCE:.md=.html}\n```\n\nAttention par contre ! En faisant ça si vous utilisez `${SOURCE}` comme cible\nd'une règle, vous allez définir plusieurs règles d'un coup, ce qui n'est peut\nêtre pas ce que vous voulez.\n\nOn peut contourner ça assez simplement en utilisant une substitution au niveau\nde la règle. La syntaxe est un poil différente :\n\n``` make\n%.html: %.md\n  [...]\n```\n\nVous l'aurez compris, `%` est identique dans la cible et dans la dépendance,\ndonc avec cette règle si vous faites un `make index.html`, *Make* va tenter de\nconstruire la dépendance `index.md` avant tout.\n\nUn problème se pose à nous avec cette syntaxe : « Bah merde, comment je récupère\nles noms de fichiers là ? »\n\n# Variables spéciales\n\nSuperbe transition étant donné qu'on va parler ici de quelques variables\nspéciales bien pratiques !\n\n- `$@` contient le nom de la cible de la règle en cours d'exécution ;\n- `$^` contient la liste des dépendances de la règle (la flèche pointe vers la\n  liste de dépendances) ;\n- `$<` contient la première dépendance de la règle (la flèche pointe à gauche,\n  là où est la dépendance).\n\nÀ l'aide de celles-ci on peut du coup compléter notre exemple précédent :\n\n``` make\n%.html: %.md\n  marked $< > $@\n  [...]\n```\n\n# Fonctions\n\nPour faciliter quelques opérations, *Make* fournit un ensemble de fonctions de\nbase. Appeler ces fonctions rappelle un peu la façon dont on lance une commande\ndans un sous-shell en Bash : `$(fonction argument1 argument2)`.\n\nVoici une petite démonstration de `wildcard`, `addsuffix` et `basename` dont\nvous vous doutez sans doute les effets :\n\n``` make\nSOURCES = $(wildcard *.md)\nDESTINATIONS = $(addsuffix .html,$(basename ${SOURCES}))\n\nall: ${DESTINATIONS}\n\n%.html: %.md\n  marked $< > $@\n```\n\nL'exemple construit dynamiquement la liste des fichiers HTML à produire à partir\nde la liste des fichiers *Markdown* disponibles puis définit une règle `all`\npermettant de tout construire d'un coup, et une règle définissant compiler\nunitairement un fichier *Markdown* vers HTML.\n\nVous noterez qu'`addsuffix`/`basename` peut être remplacé par une substitution\nsimple comme on a vu précédemment.\n\nJe vous invite à fouiller\n[le chapitre sur les fonctions du manuel][man:make:functions].\n\n# La cible `.PHONY`\n\nDans certains cas la cible d'une règle ne représente pas un fichier (c'était le\ncas de notre cible `website` [un peu plus haut](#ref-phony-target)).\n\nDans ces cas-là, on va vouloir exécuter la règle quoi qu'il arrive, comme si la\ncible était tout le temps périmée.\n\nUne cible particulière existe pour ça : `.PHONY`. Toutes les dépendances de\ncette cible seront marquées comme (traduction pourrie) imposteurs (*phony*\ndonc).\n\nPour reprendre l'exemple précédent, on déclarera donc :\n\n``` make\n.PHONY: website\n\nwebsite: index.html apropos.html contact.html\n  [...]\n```\n\nDésormais, chaque appel à `make website` tentera de construire les dépendances\net exécutera les commandes de la recette de la règle.\n\n# Un exemple complet\n\nL'exemple suivant permet de compiler un site Web depuis un ensemble de fichiers\n*Markdown*.\n\n``` make\nSOURCES = $(wildcard src/*.md)\nDESTINATIONS = ${SOURCES:src/%.md=build/%.html}\n\nall: ${DESTINATIONS}\n\ninfo:\n\t@ echo Will build ${DESTINATIONS} from ${SOURCES}\n\nclean:\n\trm -f ${DESTINATIONS}\n\nbuild/%.html: src/%.md\n\tmkdir -p build\n\tmarked $< > $@\n\n.PHONY: all info clean\n```\n\nVous noterez que comme on stocke nos résultats dans le dossier `build`, il faut\npotentiellement le créer quand on compile un fichier dedans.\n\n# Pour aller plus loin\n\nIl existe bien d'autres fonctionnalités dans *Make* (du moins dans *GNU Make*),\navec notamment :\n\n- Les [*canned recipes*][man:make:canned] (recettes en boîte), permettant de\n  définir un bout de règle réutilisable à plusieurs endroits.\n- Des [expressions conditionnelles][man:make:conditions] pour avoir des tests\n  dans votre *Makefile* et effectuer des traitements différents selon\n  l'environnement.\n- Les [règles en *order only*][man:make:types] qui permettent d'indiquer une\n  dépendance dont la date de modification ne doit pas être prise en compte (on\n  peut s'en servir pour éviter le `mkdir` dans l'exemple complet).\n- Et [plein d'autres fonctions][man:make:functions] bien pratiques !\n\nJe vous invite aussi à jeter un coup d'œil au [*Makefile* de Veil][gh:veil], un outil que\nj'utilise pour générer des sites statiques à partir de fichiers *Markdown*\n(ah bah tiens, comme dans mes exemples, c'est rigolo). Il y a plein de\nfonctionnalités de *Make* utilisées dans ce projet et je pense que ça peut être\nsource d'idées.\n\nVoilà pour cette premier introduction à *Make*, j'espère que ça vous a plu et\nque vous êtes fin prêts à affronter tous ces bouseux avec leur système de build\nà base de streams, de brocolis et autres râteaux.\n\n[p!gulp]: /posts/js/introduction-gulp/\n[p!grunt]: /posts/js/premiers-pas-avec-grunt/\n[gem:rake]: https://rubygems.org/gems/rake\n[npm:marked]: https://www.npmjs.org/package/marked\n[man:make]: https://www.gnu.org/software/make/manual/make.html\n[man:make:canned]: https://www.gnu.org/software/make/manual/make.html#Canned-Recipes\n[man:make:conditions]: https://www.gnu.org/software/make/manual/make.html#Functions\n[man:make:types]: https://www.gnu.org/software/make/manual/make.html##Prerequisite-Types\n[man:make:functions]: https://www.gnu.org/software/make/manual/make.html#Functions\n[gh:veil]: https://github.com/madx/veil/\n","raw":"---\ndate: \"2014-11-03\"\ntitle: \"Laissez-vous pousser la barbe, apprenez à écrire des Makefiles\"\ntags:\n  - shell\n  - makefile\nauthors:\n  - madx\n---\n\nÀ l'heure où tout le monde se rue sur des outils comme [Gulp][p!gulp],\n[Grunt][p!grunt] ou autres [Rake][gem:rake], certains irréductibles (dont je\nfais partie) ont fait le choix d'employer un des outils les plus standards et\nemblématiques dont tout développeur a entendu parler au moins une fois dans sa\nvie : *Make*.\n\nSi de prime abord on a l'impression d'un système assez archaïque (ce qui n'est\npas toujours forcément faux), on se rend rapidement compte que _Make_, couplé à\nune petite dose de scripting shell permet rapidement de mettre en place un moyen\nde compiler ses fichiers et de lancer des tâches.\n\nLes fichiers de configuration de _Make_ sont appellés _Makefiles_ (oui, ce sont\neux qui ont donné leurs noms aux `(Gulp|Grunt|Rake)files`). Les instructions\nqu'ils contiennent sont exécutées grâce à la commande `make` dans votre\nterminal.\n\n# Hello World\n\nJe vous propose de commencer en douceur par un classique _Hello World_. On va\nsimplement définir une tâche `hello-world` dont l'action va être d'afficher\n_\"Hello, world\"_ à l'écran (boooring).\n\n``` make\nhello-world:\n\techo \"Hello, world\"\n```\n\nPremière remarque importante, les indentations dans un _Makefile_ **doivent**\nêtre faites avec des tabulations. Oui, je sais, c'est moche, on dirait du\nPython, mais c'est comme ça.\n\nVoilà le genre d'erreurs qu'on se prend si on met des espaces à la place des\ntabulations :\n\n```\nMakefile:2: *** séparateur manquant . Arrêt.\n```\n\n\nPour exécuter notre commande, il nous suffit de lancer `make hello-world` dans\nun terminal :\n\n``` console\n$ make hello-world\necho \"Hello, world\"\nHello, world\n```\n\nDécortiquons un peu cette exécution. Pour chaque commande qu'il exécute, _Make_\naffiche la commande complète avant d'afficher la sortie standard de ladite\ncommande. C'est souvent très pratique car toutes les variables (on va revenir là dessus)\nqu'on met dans la commande sont résolues, et on voit clairement ce que _Make_\nexécute. Par contre, dans certains cas on s'en fout un peu, on peut alors\npréfixer la ligne à rendre silencieuse par un `@`, comme ça :\n\n``` make\nhello-world:\n\t@ echo \"Hello, world\"\n```\n\n``` console\n$ make hello-world\nHello, world\n```\n\n# Règles, cibles, recettes et pré-requis\n\nOK, jusque là c'est génial, on a un super outil pour lancer des commandes qu'on\npourrait déjà stocker dans un bête script shell. Pas super utile finalement.\n\nBon, on va corser un peu les choses et commencer par définir un peu de\nterminologie avant que vous soyez totalement largués.\n\nUn _Makefile_ est une collection de **règles**, chacune étant composée d'une\n**cible**, de **pré-requis** (ou pas) et d'une **recette**. Dans notre exemple\nprécédent, `hello-world` est la cible et `@ echo \"Hello, world\"` est la recette\nde la règle. Elle ne spécifie par contre pas de pré-requis.\n\nRelisez trois ou quatre fois le paragraphe précédent jusqu'à ce que ce soit bien\nimprimé.\n\nVous l'aurez compris, on invoque une règle depuis la ligne de commande en\nspécifiant le nom de sa cible après la commande `make`. Si on ne précise rien,\nc'est la première règle trouvée qui est exécutée (donc dans notre cas,\n`hello-world`).\n\nLes pré-requis sont déclarés après la cible. On pourrait par exemple ajouter un\n`sauter-une-ligne` comme pré-requis à notre cible `hello-world` :\n\n``` make\nhello-world: sauter-une-ligne\n\t@ echo \"Hello, world\"\n\nsauter-une-ligne:\n\t@ echo\n```\n\n``` console\n$ make hello-world\n\nHello, world\n```\n\nFacile, non ? Ok alors on peut *vraiment* attaquer les choses sérieuses.\n\n# Construire des fichiers\n\nLes pré-requis sont particulièrement pratiques quand on veut construire un\nfichier depuis un autre, ce qui est la principale action d'à peu près tout\nprocessus de compilation (paraît même que c'est grosso modo la définition de la\ncompilation).\n\nOn peut par exemple écrire un _Makefile_ nous permettant de compiler un fichier\n_Markdown_ en _HTML_ :\n\n``` make\narticle.html: article.md\n\tmarked article.md > article.html\n```\n\nCette règle spécifie simplement que pour construire le fichier `article.html`\nj'ai besoin du fichier `article.md` et que j'utilise la commande\n[`marked`][npm:marked] pour construire le fichier. Essayez, vous verrez, c'est\nmagique.\n\nLà où ça devient intéressant, c'est que si je lance de nouveau `make\narticle.html`, rien ne se passe. Eh oui, _Make_ vérifie les dates de\nmodification des pré-requis et les compare avec la date de modification de la\ncible pour savoir s'il doit où non reconstruire la cible.\n\nOn peut bien sûr aller plus loin en ayant des fichiers qui dépendent de\nfichiers, qui à leur tour dépendent de fichiers, …\n\n<a name=\"ref-phony-target\"></a>\n\nOn peut aussi avoir une cible factice qui ne représente pas un fichier et qui\nelle-même dépend de plusieurs fichiers (`website: index.html apropos.html\ncontact.html`).\n\n# Variables et substitutions\n\nLa syntaxe des variables dans un *Makefile* ressemblent beaucoup aux variables\nde votre Shell, *mais pas tout à fait*.\n\n``` make\nSOURCE = index.md\nDESTINATION = index.html\n\n${DESTINATION}: ${SOURCE}\n  marked ${SOURCE} > ${DESTINATION}\n```\n\nOn peut aussi utiliser une substitution pour s'éviter de tout retaper. La\nsyntaxe pour ça est assez simple et se passe d'explications :\n\n``` make\nSOURCE = index.md\nDESTINATION = ${SOURCE:.md=.html}\n```\n\nLà où ça devient beaucoup plus intéressant c'est qu'on peut stocker des listes\ndans une variable. Pour ça, pas vraiment d'effort à faire, il suffit de rajouter\ndes noms à la suite :\n\n``` make\nSOURCE = index.md article.md\nDESTINATION = ${SOURCE:.md=.html}\n```\n\nAttention par contre ! En faisant ça si vous utilisez `${SOURCE}` comme cible\nd'une règle, vous allez définir plusieurs règles d'un coup, ce qui n'est peut\nêtre pas ce que vous voulez.\n\nOn peut contourner ça assez simplement en utilisant une substitution au niveau\nde la règle. La syntaxe est un poil différente :\n\n``` make\n%.html: %.md\n  [...]\n```\n\nVous l'aurez compris, `%` est identique dans la cible et dans la dépendance,\ndonc avec cette règle si vous faites un `make index.html`, *Make* va tenter de\nconstruire la dépendance `index.md` avant tout.\n\nUn problème se pose à nous avec cette syntaxe : « Bah merde, comment je récupère\nles noms de fichiers là ? »\n\n# Variables spéciales\n\nSuperbe transition étant donné qu'on va parler ici de quelques variables\nspéciales bien pratiques !\n\n- `$@` contient le nom de la cible de la règle en cours d'exécution ;\n- `$^` contient la liste des dépendances de la règle (la flèche pointe vers la\n  liste de dépendances) ;\n- `$<` contient la première dépendance de la règle (la flèche pointe à gauche,\n  là où est la dépendance).\n\nÀ l'aide de celles-ci on peut du coup compléter notre exemple précédent :\n\n``` make\n%.html: %.md\n  marked $< > $@\n  [...]\n```\n\n# Fonctions\n\nPour faciliter quelques opérations, *Make* fournit un ensemble de fonctions de\nbase. Appeler ces fonctions rappelle un peu la façon dont on lance une commande\ndans un sous-shell en Bash : `$(fonction argument1 argument2)`.\n\nVoici une petite démonstration de `wildcard`, `addsuffix` et `basename` dont\nvous vous doutez sans doute les effets :\n\n``` make\nSOURCES = $(wildcard *.md)\nDESTINATIONS = $(addsuffix .html,$(basename ${SOURCES}))\n\nall: ${DESTINATIONS}\n\n%.html: %.md\n  marked $< > $@\n```\n\nL'exemple construit dynamiquement la liste des fichiers HTML à produire à partir\nde la liste des fichiers *Markdown* disponibles puis définit une règle `all`\npermettant de tout construire d'un coup, et une règle définissant compiler\nunitairement un fichier *Markdown* vers HTML.\n\nVous noterez qu'`addsuffix`/`basename` peut être remplacé par une substitution\nsimple comme on a vu précédemment.\n\nJe vous invite à fouiller\n[le chapitre sur les fonctions du manuel][man:make:functions].\n\n# La cible `.PHONY`\n\nDans certains cas la cible d'une règle ne représente pas un fichier (c'était le\ncas de notre cible `website` [un peu plus haut](#ref-phony-target)).\n\nDans ces cas-là, on va vouloir exécuter la règle quoi qu'il arrive, comme si la\ncible était tout le temps périmée.\n\nUne cible particulière existe pour ça : `.PHONY`. Toutes les dépendances de\ncette cible seront marquées comme (traduction pourrie) imposteurs (*phony*\ndonc).\n\nPour reprendre l'exemple précédent, on déclarera donc :\n\n``` make\n.PHONY: website\n\nwebsite: index.html apropos.html contact.html\n  [...]\n```\n\nDésormais, chaque appel à `make website` tentera de construire les dépendances\net exécutera les commandes de la recette de la règle.\n\n# Un exemple complet\n\nL'exemple suivant permet de compiler un site Web depuis un ensemble de fichiers\n*Markdown*.\n\n``` make\nSOURCES = $(wildcard src/*.md)\nDESTINATIONS = ${SOURCES:src/%.md=build/%.html}\n\nall: ${DESTINATIONS}\n\ninfo:\n\t@ echo Will build ${DESTINATIONS} from ${SOURCES}\n\nclean:\n\trm -f ${DESTINATIONS}\n\nbuild/%.html: src/%.md\n\tmkdir -p build\n\tmarked $< > $@\n\n.PHONY: all info clean\n```\n\nVous noterez que comme on stocke nos résultats dans le dossier `build`, il faut\npotentiellement le créer quand on compile un fichier dedans.\n\n# Pour aller plus loin\n\nIl existe bien d'autres fonctionnalités dans *Make* (du moins dans *GNU Make*),\navec notamment :\n\n- Les [*canned recipes*][man:make:canned] (recettes en boîte), permettant de\n  définir un bout de règle réutilisable à plusieurs endroits.\n- Des [expressions conditionnelles][man:make:conditions] pour avoir des tests\n  dans votre *Makefile* et effectuer des traitements différents selon\n  l'environnement.\n- Les [règles en *order only*][man:make:types] qui permettent d'indiquer une\n  dépendance dont la date de modification ne doit pas être prise en compte (on\n  peut s'en servir pour éviter le `mkdir` dans l'exemple complet).\n- Et [plein d'autres fonctions][man:make:functions] bien pratiques !\n\nJe vous invite aussi à jeter un coup d'œil au [*Makefile* de Veil][gh:veil], un outil que\nj'utilise pour générer des sites statiques à partir de fichiers *Markdown*\n(ah bah tiens, comme dans mes exemples, c'est rigolo). Il y a plein de\nfonctionnalités de *Make* utilisées dans ce projet et je pense que ça peut être\nsource d'idées.\n\nVoilà pour cette premier introduction à *Make*, j'espère que ça vous a plu et\nque vous êtes fin prêts à affronter tous ces bouseux avec leur système de build\nà base de streams, de brocolis et autres râteaux.\n\n[p!gulp]: /posts/js/introduction-gulp/\n[p!grunt]: /posts/js/premiers-pas-avec-grunt/\n[gem:rake]: https://rubygems.org/gems/rake\n[npm:marked]: https://www.npmjs.org/package/marked\n[man:make]: https://www.gnu.org/software/make/manual/make.html\n[man:make:canned]: https://www.gnu.org/software/make/manual/make.html#Canned-Recipes\n[man:make:conditions]: https://www.gnu.org/software/make/manual/make.html#Functions\n[man:make:types]: https://www.gnu.org/software/make/manual/make.html##Prerequisite-Types\n[man:make:functions]: https://www.gnu.org/software/make/manual/make.html#Functions\n[gh:veil]: https://github.com/madx/veil/\n","__filename":"posts/shell/apprendre-les-makefiles/index.md","__url":"/posts/shell/apprendre-les-makefiles/"}