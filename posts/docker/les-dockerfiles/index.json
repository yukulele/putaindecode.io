{"head":{"layout":"Post","comments":true,"date":"2015-07-02","title":"Les Dockerfiles","tags":["docker"],"authors":["Uhsac"],"header":{"credit":"https://www.flickr.com/photos/tristantaussac/15145365916/"}},"body":"<p>Dans <a href=\"/posts/docker/introduction-a-docker\">l’article précédent</a>, je vous ai\nprésenté le fonctionnement de base de Docker. Mais cela vous limitait à\nl’usage des images que vous pouviez trouver sur le <a href=\"https://registry.hub.docker.com/\">Docker\nHub</a>. Afin de vraiment pouvoir utiliser\nDocker au maximum, il serait appréciable de pouvoir créer des images adaptées à\nnos projets et c’est là l’utilité des Dockerfiles.</p>\n<h1 id=\"les-dockerfiles\"><a class=\"markdownIt-Anchor\" href=\"#les-dockerfiles\">#</a> Les Dockerfiles</h1>\n<p>Les Dockerfiles sont des fichiers qui permettent de construire une image Docker\nadaptée à nos besoins, étape par étape. Rentrons dans le vif du sujet en créant\nune image permettant de lancer un projet JavaScript.</p>\n<p>Pour commencer, créez un nouveau fichier <code>Dockerfile</code> à la racine de votre\nprojet.</p>\n<p>La première chose à faire dans un Dockerfile est de définir de quelle image\nvous héritez. Pour cet exemple, je vous propose d’utiliser une image de Debian\ncomme base (ce qui est une bonne pratique, car cette image\nest plutôt légère en comparaison avec celle d’Ubuntu par exemple).</p>\n<pre><code><span class=\"hljs-tag\">FROM</span> <span class=\"hljs-tag\">debian</span><span class=\"hljs-pseudo\">:jessie</span></code></pre>\n<p><code>FROM</code> permet de définir notre image de base, vous pouvez l’utiliser uniquement\nune fois dans un Dockerfile.</p>\n<p>Comme nous voulons créer une image pour une application JavaScript full-stack,\nnous devons commencer par installer Node.js. Pour ce faire, on va télécharger\nl’archive Node.js directement depuis le site officiel à l’aide de curl que nous\nallons aussi devoir installer.</p>\n<pre><code><span class=\"hljs-constant\">RUN</span> apt-get update \\\n&amp;&amp; apt-get install -y curl \\\n&amp;&amp; rm -rf /var/<span class=\"hljs-class\"><span class=\"hljs-keyword\">lib</span>/<span class=\"hljs-title\">apt</span>/<span class=\"hljs-title\">lists</span>/*</span>\n\n<span class=\"hljs-constant\">RUN</span> curl -<span class=\"hljs-constant\">LO</span> <span class=\"hljs-string\">\"https://nodejs.org/dist/v0.12.5/node-v0.12.5-linux-x64.tar.gz\"</span> \\\n&amp;&amp; tar -xzf node-v0.<span class=\"hljs-number\">12.5</span>-linux-x64.tar.gz -<span class=\"hljs-constant\">C</span> /usr/local --strip-components=<span class=\"hljs-number\">1</span> \\\n&amp;&amp; rm node-v0.<span class=\"hljs-number\">12.5</span>-linux-x64.tar.gz</code></pre>\n<p><code>RUN</code> permet d’exécuter une commande à l’intérieur de votre image comme si vous\nétiez devant un shell unix.</p>\n<p>La première commande nous permet d’installer curl et de nettoyer ensuite le\ngestionnaire de paquets afin que notre image soit un peu plus légère.</p>\n<p>Avec la deuxième commande, nous téléchargeons le binaire de Node.js que nous\ninstallons ensuite à ça place, et on n’oublie pas de supprimer l’archive\nensuite.</p>\n<p>Vous pouvez vous demander pourquoi j’exécute plusieurs commandes sur une même\ninstruction <code>RUN</code> ? Eh bien, cela permet simplement de limiter le nombre\nd’instructions dans votre Dockerfile ce qui rendra votre image finale plus\nlégère.</p>\n<p>Maintenant, nous allons ajouter les sources de notre projet dans l’image et\ntélécharger nos dépendances.</p>\n<pre><code><span class=\"hljs-built_in\">ADD</span> <span class=\"bash\">package.json /app/\n</span>\n<span class=\"hljs-built_in\">WORKDIR</span> <span class=\"bash\">/app\n</span>\n<span class=\"hljs-built_in\">RUN</span> <span class=\"bash\">npm install\n</span>\n<span class=\"hljs-built_in\">ADD</span> <span class=\"bash\">. /app/</span></code></pre>\n<p><code>ADD</code> permet d’ajouter des fichiers locaux ou distants à l’intérieur de votre\nimage, il est le plus souvent utilisé pour importer les sources de votre projet\nou des fichiers de configuration.</p>\n<p><code>WORKDIR</code> permet de changer le répertoire courant de votre image, toutes les\ncommandes qui suivront seront exécutées à partir de ce répertoire.</p>\n<p>Avec la dernière instruction, nous ajoutons les sources de notre projet à\nl’intérieur de l’image, mais vous allez vous demander pourquoi nous ne l’avons\npas fait en même temps que l’ajout des fichiers de dépendances. Eh bien, cela\nnous permet d’économiser beaucoup de temps !</p>\n<p>Quand Docker crée une nouvelle image à partir d’un Dockerfile, il exécute chaque\ninstruction dans un conteneur, et le résultat de cette instruction est\nsauvegardé sous forme de couche. Au final, une image est un assemblage de\nplusieurs couches (une par instruction). Et donc, quand vous reconstruisez une\nimage pour la seconde fois, les instructions qui n’impliquent pas de changements\nne sont pas réexécutées, car la couche est récupérée depuis l’image précédente. Par\ncontre, si l’instruction implique un changement quelconque, elle est réexécutée\nainsi que toutes les instructions suivantes.</p>\n<p>Dans notre cas, les sources auront tendance à beaucoup changer, et donc ne pas\nretélécharger les dépendances à chaque changement dans le code est un réel gain\nde temps !</p>\n<p>Maintenant, nous allons indiquer quel port et dossier nous souhaitons partager\navec l’extérieur du conteneur.</p>\n<pre><code><span class=\"hljs-built_in\">EXPOSE</span> <span class=\"hljs-number\">3000</span>\n\n<span class=\"hljs-built_in\">VOLUME</span> <span class=\"bash\">/app/<span class=\"hljs-built_in\">log</span></span></code></pre>\n<p><code>EXPOSE</code> et <code>VOLUME</code> permettent respectivement d’indiquer quel port et quel\ndossier nous souhaitons partager.</p>\n<p>Et pour finir, nous pouvons indiquer quelle instruction doit s’exécuter au\nlancement de votre conteneur grâce à l’instruction <code>CMD</code>.</p>\n<pre><code>CMD <span class=\"hljs-keyword\">node</span><span class=\"hljs-identifier\"> </span><span class=\"hljs-title\">server</span>.js</code></pre>\n<p>Voici un résumé de notre Dockerfile :</p>\n<pre><code><span class=\"hljs-comment\"># Image de base</span>\n<span class=\"hljs-built_in\">FROM</span> debian:jessie\n\n<span class=\"hljs-comment\"># Installation de curl avec apt-get</span>\n<span class=\"hljs-built_in\">RUN</span> <span class=\"bash\">apt-get update \\\n&amp;&amp; apt-get install -y curl \\\n&amp;&amp; rm -rf /var/lib/apt/lists/*\n</span>\n<span class=\"hljs-comment\"># Installation de Node.js à partir du site officiel</span>\n<span class=\"hljs-built_in\">RUN</span> <span class=\"bash\">curl -LO <span class=\"hljs-string\">\"https://nodejs.org/dist/v0.12.5/node-v0.12.5-linux-x64.tar.gz\"</span> \\\n&amp;&amp; tar -xzf node-v0.<span class=\"hljs-number\">12.5</span>-linux-x64.tar.gz -C /usr/<span class=\"hljs-built_in\">local</span> --strip-components=<span class=\"hljs-number\">1</span> \\\n&amp;&amp; rm node-v0.<span class=\"hljs-number\">12.5</span>-linux-x64.tar.gz\n</span>\n<span class=\"hljs-comment\"># Ajout du fichier de dépendances package.json </span>\n<span class=\"hljs-built_in\">ADD</span> <span class=\"bash\">package.json /app/\n</span>\n<span class=\"hljs-comment\"># Changement du repertoire courant</span>\n<span class=\"hljs-built_in\">WORKDIR</span> <span class=\"bash\">/app\n</span>\n<span class=\"hljs-comment\"># Installation des dépendances</span>\n<span class=\"hljs-built_in\">RUN</span> <span class=\"bash\">npm install\n</span>\n<span class=\"hljs-comment\"># Ajout des sources</span>\n<span class=\"hljs-built_in\">ADD</span> <span class=\"bash\">. /app/\n</span>\n<span class=\"hljs-comment\"># On expose le port 3000</span>\n<span class=\"hljs-built_in\">EXPOSE</span> <span class=\"hljs-number\">3000</span>\n\n<span class=\"hljs-comment\"># On partage un dossier de log</span>\n<span class=\"hljs-built_in\">VOLUME</span> <span class=\"bash\">/app/<span class=\"hljs-built_in\">log</span>\n</span>\n<span class=\"hljs-comment\"># On lance le serveur quand on démarre le conteneur</span>\n<span class=\"hljs-built_in\">CMD</span> <span class=\"bash\">node server.js</span></code></pre>\n<p>Avant de transformer ce Dockerfile en une image, vous devez créer un fichier de\nplus, le <code>.dockerignore</code>, ce fichier permet comme un <code>.gitignore</code> de ne pas\ninclure certain fichiers dans votre image Docker, et c’est très important afin\nd’éviter d’inclure les dépendances de votre projet dans votre image\n(<code>node_modules</code> dans notre cas) qui sont propres à votre\nsystème, mais pas au système du conteneur. Voici à quoi votre <code>.dockerignore</code>\ndoit ressembler :</p>\n<pre><code><span class=\"hljs-tag\">node_modules</span>\n<span class=\"hljs-class\">.git</span></code></pre>\n<p>Pour transformer ce Dockerfile en une image Docker, vous devez utiliser cette\ncommande :</p>\n<pre><code class=\"language-console\">$ docker build -t fullstack-js .\nSending build context to Docker daemon 4.381 MB\nSending build context to Docker daemon\nStep 0 : FROM debian:jessie\n -<span class=\"ruby\">--&gt; bf84c1d84a8f\n</span>Step 1 : RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*\n -<span class=\"ruby\">--&gt; <span class=\"hljs-constant\">Running</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">93258459</span>a279\n</span>...\n -<span class=\"ruby\">--&gt; <span class=\"hljs-number\">4</span>fffcf3749a2\n</span>Removing intermediate container 93258459a279\nStep 2 : RUN curl -LO \"https://nodejs.org/dist/v0.12.5/node-v0.12.5-linux-x64.tar.gz\" &amp;&amp; tar -xzf node-v0.12.5-linux-x64.tar.gz -C /usr/local --strip-components=1 &amp;&amp; rm node-v0.12.5-linux-x64.tar.gz\n -<span class=\"ruby\">--&gt; <span class=\"hljs-constant\">Running</span> <span class=\"hljs-keyword\">in</span> a3a17d584bae\n</span>...\n -<span class=\"ruby\">--&gt; <span class=\"hljs-number\">4</span>eaa62ace8de\n</span>Removing intermediate container a3a17d584bae\nStep 3 : ADD *.json /app/\n -<span class=\"ruby\">--&gt; <span class=\"hljs-number\">1</span>e8ffd7e10a8\n</span>Removing intermediate container 5db20e8b8ed2\nStep 4 : WORKDIR /app\n -<span class=\"ruby\">--&gt; <span class=\"hljs-constant\">Running</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">7</span>b84b06642b1\n</span> -<span class=\"ruby\">--&gt; <span class=\"hljs-number\">9</span>c0e2287c34d\n</span>Removing intermediate container 7b84b06642b1\nStep 5 : RUN npm install\n -<span class=\"ruby\">--&gt; <span class=\"hljs-constant\">Running</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0523</span>df6e9aac\n</span>...\n -<span class=\"ruby\">--&gt; <span class=\"hljs-number\">6</span>d7327ebee3<span class=\"hljs-number\">0</span>\n</span>Removing intermediate container 0523df6e9aac\nStep 6 : ADD . /app\n -<span class=\"ruby\">--&gt; <span class=\"hljs-number\">13</span>bdbe70c6fa\n</span>Removing intermediate container 3c83d82c1d53\nStep 7 : EXPOSE 3000\n -<span class=\"ruby\">--&gt; <span class=\"hljs-constant\">Running</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">51</span>e252173b12\n</span> -<span class=\"ruby\">--&gt; <span class=\"hljs-number\">6</span>c62eb1197e2\n</span>Removing intermediate container 51e252173b12\nStep 8 : VOLUME /app/log\n -<span class=\"ruby\">--&gt; <span class=\"hljs-constant\">Running</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">4</span>af0bb73307b\n</span> -<span class=\"ruby\">--&gt; <span class=\"hljs-number\">15</span>b6190de473\n</span>Removing intermediate container 4af0bb73307b\nStep 9 : CMD node server.js\n -<span class=\"ruby\">--&gt; <span class=\"hljs-constant\">Running</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">9522</span>c6b9bf95\n</span> -<span class=\"ruby\">--&gt; aaf20fb25dac\n</span>Removing intermediate container 9522c6b9bf95\nSuccessfully built aaf20fb25dac</code></pre>\n<p>L’option <code>-t</code> permet de nommer votre image docker, ce qui vous servira lorsque\nvous voudrez lancer votre conteneur. Et le <code>.</code> est le repertoire où se trouve\nle Dockerfile, dans notre cas le dossier courant.</p>\n<p>Maintenant, vous pouvez lancer votre conteneur de cette manière :</p>\n<pre><code class=\"language-console\">$ docker <span class=\"hljs-keyword\">run</span> -<span class=\"hljs-keyword\">d</span> -p 3000:3000 -v $(<span class=\"hljs-keyword\">pwd</span>)/<span class=\"hljs-keyword\">log</span>:/<span class=\"hljs-keyword\">app</span>/<span class=\"hljs-keyword\">log</span> fullstack-js</code></pre>\n<p>Cette commande permet de lancer notre image en partageant le port et un dossier\navec votre ordinateur, si vous voulez plus de détails sur le fonctionnement du\nclient Docker, je vous invite à lire mon <a href=\"/posts/docker/introduction-a-docker\">article\nprécédent</a>.</p>\n<hr>\n<p>Dans cet article, vous avez pu voir comment créer votre propre Dockerfile,\nmaintenant vous pouvez créer des images Docker parfaitement adaptées à votre\nprojet, et même plus. En cherchant sur Internet, vous pourrez trouver des images\nDocker pour tout et n’importe quoi, comme des images pour lancer Chrome dans un\nconteneur par exemple. Pour en savoir plus, je vous redirige vers le\nblog de <a href=\"https://blog.jessfraz.com/post/docker-containers-on-the-desktop/\">Jessie\nFrazelle</a>.</p>\n<p>Dans le prochain article, je vous parlerai de docker-compose, un outil qui\npermet de lancer des applications multi-conteneurs facilement.</p>\n","rawBody":"\nDans [l'article précédent](/posts/docker/introduction-a-docker), je vous ai\nprésenté le fonctionnement de base de Docker. Mais cela vous limitait à\nl'usage des images que vous pouviez trouver sur le [Docker\nHub](https://registry.hub.docker.com/). Afin de vraiment pouvoir utiliser\nDocker au maximum, il serait appréciable de pouvoir créer des images adaptées à\nnos projets et c'est là l'utilité des Dockerfiles.\n\n# Les Dockerfiles\n\nLes Dockerfiles sont des fichiers qui permettent de construire une image Docker\nadaptée à nos besoins, étape par étape. Rentrons dans le vif du sujet en créant\nune image permettant de lancer un projet JavaScript.\n\nPour commencer, créez un nouveau fichier `Dockerfile` à la racine de votre\nprojet.\n\nLa première chose à faire dans un Dockerfile est de définir de quelle image\nvous héritez. Pour cet exemple, je vous propose d'utiliser une image de Debian\ncomme base (ce qui est une bonne pratique, car cette image\nest plutôt légère en comparaison avec celle d'Ubuntu par exemple).\n\n```\nFROM debian:jessie\n```\n\n`FROM` permet de définir notre image de base, vous pouvez l'utiliser uniquement\nune fois dans un Dockerfile.\n\nComme nous voulons créer une image pour une application JavaScript full-stack,\nnous devons commencer par installer Node.js. Pour ce faire, on va télécharger\nl'archive Node.js directement depuis le site officiel à l'aide de curl que nous\nallons aussi devoir installer.\n\n```\nRUN apt-get update \\\n&& apt-get install -y curl \\\n&& rm -rf /var/lib/apt/lists/*\n\nRUN curl -LO \"https://nodejs.org/dist/v0.12.5/node-v0.12.5-linux-x64.tar.gz\" \\\n&& tar -xzf node-v0.12.5-linux-x64.tar.gz -C /usr/local --strip-components=1 \\\n&& rm node-v0.12.5-linux-x64.tar.gz\n```\n\n`RUN` permet d'exécuter une commande à l'intérieur de votre image comme si vous\nétiez devant un shell unix. \n\nLa première commande nous permet d'installer curl et de nettoyer ensuite le\ngestionnaire de paquets afin que notre image soit un peu plus légère.\n\nAvec la deuxième commande, nous téléchargeons le binaire de Node.js que nous\ninstallons ensuite à ça place, et on n'oublie pas de supprimer l'archive\nensuite.\n\nVous pouvez vous demander pourquoi j'exécute plusieurs commandes sur une même\ninstruction `RUN` ? Eh bien, cela permet simplement de limiter le nombre\nd'instructions dans votre Dockerfile ce qui rendra votre image finale plus\nlégère.\n\nMaintenant, nous allons ajouter les sources de notre projet dans l'image et\ntélécharger nos dépendances.\n\n```\nADD package.json /app/\n\nWORKDIR /app\n\nRUN npm install\n\nADD . /app/\n```\n\n`ADD` permet d'ajouter des fichiers locaux ou distants à l'intérieur de votre\nimage, il est le plus souvent utilisé pour importer les sources de votre projet\nou des fichiers de configuration.\n\n`WORKDIR` permet de changer le répertoire courant de votre image, toutes les\ncommandes qui suivront seront exécutées à partir de ce répertoire.\n\nAvec la dernière instruction, nous ajoutons les sources de notre projet à\nl'intérieur de l'image, mais vous allez vous demander pourquoi nous ne l'avons\npas fait en même temps que l'ajout des fichiers de dépendances. Eh bien, cela\nnous permet d'économiser beaucoup de temps ! \n\nQuand Docker crée une nouvelle image à partir d'un Dockerfile, il exécute chaque\ninstruction dans un conteneur, et le résultat de cette instruction est\nsauvegardé sous forme de couche. Au final, une image est un assemblage de\nplusieurs couches (une par instruction). Et donc, quand vous reconstruisez une\nimage pour la seconde fois, les instructions qui n'impliquent pas de changements\nne sont pas réexécutées, car la couche est récupérée depuis l'image précédente. Par\ncontre, si l'instruction implique un changement quelconque, elle est réexécutée\nainsi que toutes les instructions suivantes.\n\nDans notre cas, les sources auront tendance à beaucoup changer, et donc ne pas\nretélécharger les dépendances à chaque changement dans le code est un réel gain\nde temps !\n\nMaintenant, nous allons indiquer quel port et dossier nous souhaitons partager\navec l'extérieur du conteneur.\n\n```\nEXPOSE 3000\n\nVOLUME /app/log\n```\n`EXPOSE` et `VOLUME` permettent respectivement d'indiquer quel port et quel\ndossier nous souhaitons partager.\n\nEt pour finir, nous pouvons indiquer quelle instruction doit s'exécuter au\nlancement de votre conteneur grâce à l'instruction `CMD`.\n\n```\nCMD node server.js \n```\n\nVoici un résumé de notre Dockerfile :\n\n```\n# Image de base\nFROM debian:jessie\n\n# Installation de curl avec apt-get\nRUN apt-get update \\\n&& apt-get install -y curl \\\n&& rm -rf /var/lib/apt/lists/*\n\n# Installation de Node.js à partir du site officiel\nRUN curl -LO \"https://nodejs.org/dist/v0.12.5/node-v0.12.5-linux-x64.tar.gz\" \\\n&& tar -xzf node-v0.12.5-linux-x64.tar.gz -C /usr/local --strip-components=1 \\\n&& rm node-v0.12.5-linux-x64.tar.gz\n\n# Ajout du fichier de dépendances package.json \nADD package.json /app/\n\n# Changement du repertoire courant\nWORKDIR /app\n\n# Installation des dépendances\nRUN npm install\n\n# Ajout des sources\nADD . /app/\n\n# On expose le port 3000\nEXPOSE 3000\n\n# On partage un dossier de log\nVOLUME /app/log\n\n# On lance le serveur quand on démarre le conteneur\nCMD node server.js\n```\n\nAvant de transformer ce Dockerfile en une image, vous devez créer un fichier de\nplus, le `.dockerignore`, ce fichier permet comme un `.gitignore` de ne pas\ninclure certain fichiers dans votre image Docker, et c'est très important afin\nd'éviter d'inclure les dépendances de votre projet dans votre image\n(`node_modules` dans notre cas) qui sont propres à votre\nsystème, mais pas au système du conteneur. Voici à quoi votre `.dockerignore`\ndoit ressembler :\n\n```\nnode_modules\n.git\n```\n\nPour transformer ce Dockerfile en une image Docker, vous devez utiliser cette\ncommande :\n\n```console\n$ docker build -t fullstack-js .\nSending build context to Docker daemon 4.381 MB\nSending build context to Docker daemon\nStep 0 : FROM debian:jessie\n ---> bf84c1d84a8f\nStep 1 : RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*\n ---> Running in 93258459a279\n...\n ---> 4fffcf3749a2\nRemoving intermediate container 93258459a279\nStep 2 : RUN curl -LO \"https://nodejs.org/dist/v0.12.5/node-v0.12.5-linux-x64.tar.gz\" && tar -xzf node-v0.12.5-linux-x64.tar.gz -C /usr/local --strip-components=1 && rm node-v0.12.5-linux-x64.tar.gz\n ---> Running in a3a17d584bae\n...\n ---> 4eaa62ace8de\nRemoving intermediate container a3a17d584bae\nStep 3 : ADD *.json /app/\n ---> 1e8ffd7e10a8\nRemoving intermediate container 5db20e8b8ed2\nStep 4 : WORKDIR /app\n ---> Running in 7b84b06642b1\n ---> 9c0e2287c34d\nRemoving intermediate container 7b84b06642b1\nStep 5 : RUN npm install\n ---> Running in 0523df6e9aac\n...\n ---> 6d7327ebee30\nRemoving intermediate container 0523df6e9aac\nStep 6 : ADD . /app\n ---> 13bdbe70c6fa\nRemoving intermediate container 3c83d82c1d53\nStep 7 : EXPOSE 3000\n ---> Running in 51e252173b12\n ---> 6c62eb1197e2\nRemoving intermediate container 51e252173b12\nStep 8 : VOLUME /app/log\n ---> Running in 4af0bb73307b\n ---> 15b6190de473\nRemoving intermediate container 4af0bb73307b\nStep 9 : CMD node server.js\n ---> Running in 9522c6b9bf95\n ---> aaf20fb25dac\nRemoving intermediate container 9522c6b9bf95\nSuccessfully built aaf20fb25dac\n```\n\nL'option `-t` permet de nommer votre image docker, ce qui vous servira lorsque\nvous voudrez lancer votre conteneur. Et le `.` est le repertoire où se trouve\nle Dockerfile, dans notre cas le dossier courant.\n\nMaintenant, vous pouvez lancer votre conteneur de cette manière :\n\n```console\n$ docker run -d -p 3000:3000 -v $(pwd)/log:/app/log fullstack-js\n```\n\nCette commande permet de lancer notre image en partageant le port et un dossier\navec votre ordinateur, si vous voulez plus de détails sur le fonctionnement du\nclient Docker, je vous invite à lire mon [article\nprécédent](/posts/docker/introduction-a-docker).\n\n---\n\nDans cet article, vous avez pu voir comment créer votre propre Dockerfile,\nmaintenant vous pouvez créer des images Docker parfaitement adaptées à votre\nprojet, et même plus. En cherchant sur Internet, vous pourrez trouver des images\nDocker pour tout et n'importe quoi, comme des images pour lancer Chrome dans un\nconteneur par exemple. Pour en savoir plus, je vous redirige vers le\nblog de [Jessie\nFrazelle](https://blog.jessfraz.com/post/docker-containers-on-the-desktop/).\n\nDans le prochain article, je vous parlerai de docker-compose, un outil qui\npermet de lancer des applications multi-conteneurs facilement.\n","raw":"---\ndate: \"2015-07-02\"\ntitle: Les Dockerfiles\ntags:\n  - docker\nauthors:\n  - Uhsac\nheader:\n  credit: https://www.flickr.com/photos/tristantaussac/15145365916/\n---\n\nDans [l'article précédent](/posts/docker/introduction-a-docker), je vous ai\nprésenté le fonctionnement de base de Docker. Mais cela vous limitait à\nl'usage des images que vous pouviez trouver sur le [Docker\nHub](https://registry.hub.docker.com/). Afin de vraiment pouvoir utiliser\nDocker au maximum, il serait appréciable de pouvoir créer des images adaptées à\nnos projets et c'est là l'utilité des Dockerfiles.\n\n# Les Dockerfiles\n\nLes Dockerfiles sont des fichiers qui permettent de construire une image Docker\nadaptée à nos besoins, étape par étape. Rentrons dans le vif du sujet en créant\nune image permettant de lancer un projet JavaScript.\n\nPour commencer, créez un nouveau fichier `Dockerfile` à la racine de votre\nprojet.\n\nLa première chose à faire dans un Dockerfile est de définir de quelle image\nvous héritez. Pour cet exemple, je vous propose d'utiliser une image de Debian\ncomme base (ce qui est une bonne pratique, car cette image\nest plutôt légère en comparaison avec celle d'Ubuntu par exemple).\n\n```\nFROM debian:jessie\n```\n\n`FROM` permet de définir notre image de base, vous pouvez l'utiliser uniquement\nune fois dans un Dockerfile.\n\nComme nous voulons créer une image pour une application JavaScript full-stack,\nnous devons commencer par installer Node.js. Pour ce faire, on va télécharger\nl'archive Node.js directement depuis le site officiel à l'aide de curl que nous\nallons aussi devoir installer.\n\n```\nRUN apt-get update \\\n&& apt-get install -y curl \\\n&& rm -rf /var/lib/apt/lists/*\n\nRUN curl -LO \"https://nodejs.org/dist/v0.12.5/node-v0.12.5-linux-x64.tar.gz\" \\\n&& tar -xzf node-v0.12.5-linux-x64.tar.gz -C /usr/local --strip-components=1 \\\n&& rm node-v0.12.5-linux-x64.tar.gz\n```\n\n`RUN` permet d'exécuter une commande à l'intérieur de votre image comme si vous\nétiez devant un shell unix. \n\nLa première commande nous permet d'installer curl et de nettoyer ensuite le\ngestionnaire de paquets afin que notre image soit un peu plus légère.\n\nAvec la deuxième commande, nous téléchargeons le binaire de Node.js que nous\ninstallons ensuite à ça place, et on n'oublie pas de supprimer l'archive\nensuite.\n\nVous pouvez vous demander pourquoi j'exécute plusieurs commandes sur une même\ninstruction `RUN` ? Eh bien, cela permet simplement de limiter le nombre\nd'instructions dans votre Dockerfile ce qui rendra votre image finale plus\nlégère.\n\nMaintenant, nous allons ajouter les sources de notre projet dans l'image et\ntélécharger nos dépendances.\n\n```\nADD package.json /app/\n\nWORKDIR /app\n\nRUN npm install\n\nADD . /app/\n```\n\n`ADD` permet d'ajouter des fichiers locaux ou distants à l'intérieur de votre\nimage, il est le plus souvent utilisé pour importer les sources de votre projet\nou des fichiers de configuration.\n\n`WORKDIR` permet de changer le répertoire courant de votre image, toutes les\ncommandes qui suivront seront exécutées à partir de ce répertoire.\n\nAvec la dernière instruction, nous ajoutons les sources de notre projet à\nl'intérieur de l'image, mais vous allez vous demander pourquoi nous ne l'avons\npas fait en même temps que l'ajout des fichiers de dépendances. Eh bien, cela\nnous permet d'économiser beaucoup de temps ! \n\nQuand Docker crée une nouvelle image à partir d'un Dockerfile, il exécute chaque\ninstruction dans un conteneur, et le résultat de cette instruction est\nsauvegardé sous forme de couche. Au final, une image est un assemblage de\nplusieurs couches (une par instruction). Et donc, quand vous reconstruisez une\nimage pour la seconde fois, les instructions qui n'impliquent pas de changements\nne sont pas réexécutées, car la couche est récupérée depuis l'image précédente. Par\ncontre, si l'instruction implique un changement quelconque, elle est réexécutée\nainsi que toutes les instructions suivantes.\n\nDans notre cas, les sources auront tendance à beaucoup changer, et donc ne pas\nretélécharger les dépendances à chaque changement dans le code est un réel gain\nde temps !\n\nMaintenant, nous allons indiquer quel port et dossier nous souhaitons partager\navec l'extérieur du conteneur.\n\n```\nEXPOSE 3000\n\nVOLUME /app/log\n```\n`EXPOSE` et `VOLUME` permettent respectivement d'indiquer quel port et quel\ndossier nous souhaitons partager.\n\nEt pour finir, nous pouvons indiquer quelle instruction doit s'exécuter au\nlancement de votre conteneur grâce à l'instruction `CMD`.\n\n```\nCMD node server.js \n```\n\nVoici un résumé de notre Dockerfile :\n\n```\n# Image de base\nFROM debian:jessie\n\n# Installation de curl avec apt-get\nRUN apt-get update \\\n&& apt-get install -y curl \\\n&& rm -rf /var/lib/apt/lists/*\n\n# Installation de Node.js à partir du site officiel\nRUN curl -LO \"https://nodejs.org/dist/v0.12.5/node-v0.12.5-linux-x64.tar.gz\" \\\n&& tar -xzf node-v0.12.5-linux-x64.tar.gz -C /usr/local --strip-components=1 \\\n&& rm node-v0.12.5-linux-x64.tar.gz\n\n# Ajout du fichier de dépendances package.json \nADD package.json /app/\n\n# Changement du repertoire courant\nWORKDIR /app\n\n# Installation des dépendances\nRUN npm install\n\n# Ajout des sources\nADD . /app/\n\n# On expose le port 3000\nEXPOSE 3000\n\n# On partage un dossier de log\nVOLUME /app/log\n\n# On lance le serveur quand on démarre le conteneur\nCMD node server.js\n```\n\nAvant de transformer ce Dockerfile en une image, vous devez créer un fichier de\nplus, le `.dockerignore`, ce fichier permet comme un `.gitignore` de ne pas\ninclure certain fichiers dans votre image Docker, et c'est très important afin\nd'éviter d'inclure les dépendances de votre projet dans votre image\n(`node_modules` dans notre cas) qui sont propres à votre\nsystème, mais pas au système du conteneur. Voici à quoi votre `.dockerignore`\ndoit ressembler :\n\n```\nnode_modules\n.git\n```\n\nPour transformer ce Dockerfile en une image Docker, vous devez utiliser cette\ncommande :\n\n```console\n$ docker build -t fullstack-js .\nSending build context to Docker daemon 4.381 MB\nSending build context to Docker daemon\nStep 0 : FROM debian:jessie\n ---> bf84c1d84a8f\nStep 1 : RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*\n ---> Running in 93258459a279\n...\n ---> 4fffcf3749a2\nRemoving intermediate container 93258459a279\nStep 2 : RUN curl -LO \"https://nodejs.org/dist/v0.12.5/node-v0.12.5-linux-x64.tar.gz\" && tar -xzf node-v0.12.5-linux-x64.tar.gz -C /usr/local --strip-components=1 && rm node-v0.12.5-linux-x64.tar.gz\n ---> Running in a3a17d584bae\n...\n ---> 4eaa62ace8de\nRemoving intermediate container a3a17d584bae\nStep 3 : ADD *.json /app/\n ---> 1e8ffd7e10a8\nRemoving intermediate container 5db20e8b8ed2\nStep 4 : WORKDIR /app\n ---> Running in 7b84b06642b1\n ---> 9c0e2287c34d\nRemoving intermediate container 7b84b06642b1\nStep 5 : RUN npm install\n ---> Running in 0523df6e9aac\n...\n ---> 6d7327ebee30\nRemoving intermediate container 0523df6e9aac\nStep 6 : ADD . /app\n ---> 13bdbe70c6fa\nRemoving intermediate container 3c83d82c1d53\nStep 7 : EXPOSE 3000\n ---> Running in 51e252173b12\n ---> 6c62eb1197e2\nRemoving intermediate container 51e252173b12\nStep 8 : VOLUME /app/log\n ---> Running in 4af0bb73307b\n ---> 15b6190de473\nRemoving intermediate container 4af0bb73307b\nStep 9 : CMD node server.js\n ---> Running in 9522c6b9bf95\n ---> aaf20fb25dac\nRemoving intermediate container 9522c6b9bf95\nSuccessfully built aaf20fb25dac\n```\n\nL'option `-t` permet de nommer votre image docker, ce qui vous servira lorsque\nvous voudrez lancer votre conteneur. Et le `.` est le repertoire où se trouve\nle Dockerfile, dans notre cas le dossier courant.\n\nMaintenant, vous pouvez lancer votre conteneur de cette manière :\n\n```console\n$ docker run -d -p 3000:3000 -v $(pwd)/log:/app/log fullstack-js\n```\n\nCette commande permet de lancer notre image en partageant le port et un dossier\navec votre ordinateur, si vous voulez plus de détails sur le fonctionnement du\nclient Docker, je vous invite à lire mon [article\nprécédent](/posts/docker/introduction-a-docker).\n\n---\n\nDans cet article, vous avez pu voir comment créer votre propre Dockerfile,\nmaintenant vous pouvez créer des images Docker parfaitement adaptées à votre\nprojet, et même plus. En cherchant sur Internet, vous pourrez trouver des images\nDocker pour tout et n'importe quoi, comme des images pour lancer Chrome dans un\nconteneur par exemple. Pour en savoir plus, je vous redirige vers le\nblog de [Jessie\nFrazelle](https://blog.jessfraz.com/post/docker-containers-on-the-desktop/).\n\nDans le prochain article, je vous parlerai de docker-compose, un outil qui\npermet de lancer des applications multi-conteneurs facilement.\n","__filename":"posts/docker/les-dockerfiles/index.md","__url":"/posts/docker/les-dockerfiles/"}