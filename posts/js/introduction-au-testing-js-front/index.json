{"head":{"layout":"Post","comments":true,"date":"2014-05-01","title":"Introduction au testing js front","tags":["javascript","tape","unit-test","browserify"],"authors":["bloodyowl"]},"body":"<p>Les tests automatisés en front-end ont longtemps été ignorés,\net le sont encore trop.</p>\n<p>Écrire des tests peut paraître chiant, mais le temps qu’ils rapportent\ncompense largement celui que l’on passe à les écrire.</p>\n<h2 id=\"crire-du-js-testable\"><a class=\"markdownIt-Anchor\" href=\"#crire-du-js-testable\">#</a> Écrire du js testable</h2>\n<p>Prenons un exemple simple et moche :</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">//app.js</span>\n;(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n\n  <span class=\"hljs-keyword\">var</span> cart = $(<span class=\"hljs-string\">\"#cart\"</span>)\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addToCart</span>(<span class=\"hljs-params\">id</span>)</span>{\n    <span class=\"hljs-keyword\">var</span> element = $(<span class=\"hljs-string\">\"&lt;li&gt;&lt;/li&gt;\"</span>)\n    element.html(catalog[id])\n    cart.append(element)\n  }\n\n  $(<span class=\"hljs-string\">\".js-updateCart\"</span>)\n    .on(<span class=\"hljs-string\">\"click\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">eventObject</span>)</span>{\n      addToCart($(<span class=\"hljs-keyword\">this</span>).data(<span class=\"hljs-string\">\"id\"</span>))\n    })\n\n})()</code></pre>\n<p>Tester ce code est particulièrement lourd, pour plusieurs raisons :</p>\n<ul>\n<li>les functions à tester ne sont pas accessibles</li>\n<li>on doit simuler un <code>click</code> pour tester un comportement logique.</li>\n<li>on doit créer un element et modifier son <code>data-id</code> à chaque cas souhaité.</li>\n<li>pour tester <code>addToCart</code> on doit aller regarder dans le DOM.</li>\n</ul>\n<h3 id=\"1-rendez-accessibles-vos-m-thodes-au-test-runner\"><a class=\"markdownIt-Anchor\" href=\"#1-rendez-accessibles-vos-m-thodes-au-test-runner\">#</a> 1. Rendez accessibles vos méthodes au test runner</h3>\n<p>Vous pouvez utiliser un namespace adéquat.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> app = <span class=\"hljs-built_in\">window</span>.app = {}\napp.cart = {}\napp.cart.addToCart = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{ <span class=\"hljs-comment\">/* … */</span> }</code></pre>\n<p>Mais ne souhaitez probablement pas rendre vos méthodes accessibles à la console.</p>\n<p>Utilisez un module-system : <a href=\"http://browserify.org\">browserify</a> ou\n<a href=\"http://requirejs.org\">requirejs</a> (si vous n’avez pas besoin de chargement\nconditionnel et souhaitez créer un bundle par build, utilisez browserify qui\npossède une syntaxe beaucoup plus sympathique et une codebase réduite, vous\npourrez même <code>require</code> depuis un module npm\n<a href=\"/posts/js/browserify-all-the-things/\">comme on vous l’explique dans un article dédié</a>).</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> $ = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"jquery\"</span>) <span class=\"hljs-comment\">// oh, un module npm</span>\n\n<span class=\"hljs-built_in\">module</span>.exports = {\n  element : $(<span class=\"hljs-string\">\"#cart\"</span>),\n  addToCart : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n    <span class=\"hljs-comment\">/* … */</span>\n  }\n}</code></pre>\n<p>Vous pourrez ainsi séparer proprement votre application en modules et les tester individuellement.</p>\n<h3 id=\"2-oui-mais-les-modules-interd-pendants-alors\"><a class=\"markdownIt-Anchor\" href=\"#2-oui-mais-les-modules-interd-pendants-alors\">#</a> 2. Oui, mais les modules interdépendants alors ?</h3>\n<p>Là, ça devient un peu plus tricky.\nCe que je conseille à titre personnel c’est d’utiliser des events\npour faire communiquer les différentes parties de l’application.</p>\n<p>Cela permet d’éviter d’utiliser des mocks d’autres parties de l’application partout.</p>\n<p>Par exemple, si je souhaite tester le fait qu’un click sur <code>.js-updateCart</code>\ndéclanchera bien <code>updateCart</code> :</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">//view.js</span>\n\n<span class=\"hljs-comment\">// view est une petite class qui route les events</span>\n<span class=\"hljs-comment\">// en rendant les listeners accessibles aux tests</span>\n<span class=\"hljs-comment\">// vous pouvez très facilement en concevoir une</span>\n<span class=\"hljs-comment\">// à votre goût en quelques lignes de code</span>\n<span class=\"hljs-keyword\">var</span> view = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"../lib/view\"</span>)\n\n<span class=\"hljs-comment\">// eventbus est l'event bus de l'application, il orchestre</span>\n<span class=\"hljs-comment\">// la communication entre les différents modules</span>\n<span class=\"hljs-keyword\">var</span> eventbus = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"../eventbus\"</span>)\n\n<span class=\"hljs-keyword\">var</span> $ = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"jquery\"</span>)\n\n<span class=\"hljs-built_in\">module</span>.exports = view.extend({\n  element : <span class=\"hljs-built_in\">document</span>.body,\n  events : [\n    {\n      type : <span class=\"hljs-string\">\"click\"</span>,\n      selector : <span class=\"hljs-string\">\".js-addToCart\"</span>,\n      listener : <span class=\"hljs-string\">\"addToCart\"</span>\n    }\n  ],\n  addToCart : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">eventObject</span>)</span>{\n    <span class=\"hljs-keyword\">var</span> target = eventObject.currentTarget\n    <span class=\"hljs-keyword\">var</span> id = $(target).data(<span class=\"hljs-string\">\"id\"</span>)\n    eventbus.fire(<span class=\"hljs-string\">\"addToCart\"</span>, {\n      id : id\n    })\n  }\n})</code></pre>\n<p>et je n’aurais qu’à écouter cet event depuis <code>cart</code> :</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// cart.js</span>\n<span class=\"hljs-keyword\">var</span> eventbus = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"../eventbus\"</span>)\n<span class=\"hljs-keyword\">var</span> catalog = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"../catalog\"</span>)\n\n<span class=\"hljs-built_in\">module</span>.exports = {\n  initialize : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n    <span class=\"hljs-keyword\">this</span>._addToCart = <span class=\"hljs-keyword\">this</span>.addToCart.bind(<span class=\"hljs-keyword\">this</span>)\n    eventbus.listen(<span class=\"hljs-string\">\"addToCart\"</span>, <span class=\"hljs-keyword\">this</span>._addToCart)\n  },\n  release : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{\n    eventbus.stopListening(<span class=\"hljs-string\">\"addToCart\"</span>, <span class=\"hljs-keyword\">this</span>._addToCart)\n  },\n  addToCart : <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">eventObject</span>)</span>{\n    <span class=\"hljs-comment\">// et on a eventObject.id</span>\n    <span class=\"hljs-keyword\">this</span>.products.push(catalog[eventObject.currentTarget.data(<span class=\"hljs-string\">\"id\"</span>)])\n  }\n}</code></pre>\n<p>Grâce à cette architecture, je vais pouvoir tester individuellement\nles deux modules.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// view.test.js</span>\n\n<span class=\"hljs-keyword\">var</span> tape = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"tape\"</span>)\n<span class=\"hljs-keyword\">var</span> view = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"../app/view\"</span>)\n<span class=\"hljs-keyword\">var</span> eventbus = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"../eventbus\"</span>)\n<span class=\"hljs-keyword\">var</span> $ = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"jquery\"</span>)\n\ntape(<span class=\"hljs-string\">\"view\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">test</span>)</span>{\n  test.plan(<span class=\"hljs-number\">1</span>)\n  <span class=\"hljs-keyword\">var</span> element = $(<span class=\"hljs-string\">\"&lt;div&gt;&lt;/div&gt;\"</span>)\n  element.data(<span class=\"hljs-string\">\"id\"</span>, <span class=\"hljs-number\">1</span>)\n  <span class=\"hljs-comment\">// on teste facilement l'envoi</span>\n  eventbus.listen(<span class=\"hljs-string\">\"addToCart\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">eventObject</span>)</span>{\n    test.equal(eventObject.id, <span class=\"hljs-number\">1</span>)\n  })\n  view.addToCart({\n    currentTarget : element\n  })\n})</code></pre>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// cart.test.js</span>\n\n<span class=\"hljs-keyword\">var</span> tape = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"tape\"</span>)\n<span class=\"hljs-keyword\">var</span> cart = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"../app/cart\"</span>)\n<span class=\"hljs-keyword\">var</span> eventbus = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"../eventbus\"</span>)\n<span class=\"hljs-keyword\">var</span> catalog = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"../catalog\"</span>)\n\ntape(<span class=\"hljs-string\">\"cart\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">test</span>)</span>{\n  cart.initialize()\n  eventbus.fireSync(<span class=\"hljs-string\">\"addToCart\"</span>, {id:<span class=\"hljs-number\">1</span>})\n  test.deepEqual(\n    cart[<span class=\"hljs-number\">0</span>],\n    catalog[<span class=\"hljs-number\">1</span>],\n    <span class=\"hljs-string\">\"receives addToCart event\"</span>\n  )\n  test.end()\n})</code></pre>\n<h2 id=\"tester-tous-les-cas-possibles\"><a class=\"markdownIt-Anchor\" href=\"#tester-tous-les-cas-possibles\">#</a> Tester tous les cas possibles</h2>\n<p>Ce sont souvent les edge-cases qui nous font nous arracher les cheveux.\nPour pallier ces soucis, tester en profondeur est essentiel.</p>\n<p>Prenons un exemple, une méthode qui teste si la valeur qu’on lui passe est\nune <code>string</code>.</p>\n<p>On serait tenté de simplement tester les résultats positifs de cette façon :</p>\n<pre><code class=\"language-javascript\">tape(<span class=\"hljs-string\">\"type.isString on strings\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">test</span>)</span>{\n  test.equal(type.isString(<span class=\"hljs-string\">\"\"</span>), <span class=\"hljs-literal\">true</span>)\n  test.end()\n})</code></pre>\n<p>Or, si par mégarde ma méthode <code>isString</code> se révèle être :</p>\n<pre><code class=\"language-javascript\">type.isString = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> value == <span class=\"hljs-string\">\"string\"</span>\n}</code></pre>\n<p>on ne vérifie pas le cas <code>type.isString(new String(&quot;&quot;))</code>.</p>\n<p>Du coup, des tests complets :</p>\n<pre><code class=\"language-javascript\">tape(<span class=\"hljs-string\">\"type.isString on strings\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">test</span>)</span>{\n  test.equal(type.isString(<span class=\"hljs-string\">\"\"</span>), <span class=\"hljs-literal\">true</span>)\n  test.equal(type.isString(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">String</span>(<span class=\"hljs-string\">\"\"</span>)), <span class=\"hljs-literal\">false</span>)\n  test.end()\n})</code></pre>\n<p>permettent ici d’identifier qu’en réalité on a besoin de :</p>\n<pre><code class=\"language-javascript\">type.isString = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">value</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Object</span>.prototype.toString.call(value) == <span class=\"hljs-string\">\"[object String]\"</span>\n}</code></pre>\n<p>Et c’est à la force des résultats de tests que vous identifierez rapidement\nvous familiariserez à tous ces edge-cases.</p>\n<p>À chaque correctif de bug, ajoutez des tests (mais ça, vous le saviez déjà).</p>\n<h2 id=\"cross-browser-testing\"><a class=\"markdownIt-Anchor\" href=\"#cross-browser-testing\">#</a> Cross-browser testing</h2>\n<p>À l’heure actuelle, où l’on se trouve notamment très souvent avec du\nfeature testing.\nPour le tester complètement, on doit se servir de vrais navigateurs :\nun headless (certes, très pratique) comme <a href=\"http://phantomjs.org\">phantomjs</a>\nne permettra pas d’obtenir 100% de coverage.</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">var</span> supportsAnimationFrame =\n  !!(\n    win.requestAnimationFrame ||\n    win.webkitRequestAnimationFrame ||\n    win.mozRequestAnimationFrame ||\n    win.ORequestAnimationFrame ||\n    <span class=\"hljs-comment\">// vous avez fait une faute de frappe,</span>\n    <span class=\"hljs-comment\">// et mis un `O` majuscule, seul un</span>\n    <span class=\"hljs-comment\">// test sur les version concernées d'Opera</span>\n    <span class=\"hljs-comment\">// vous permettront de l'identifier</span>\n    win.msRequestAnimationFrame\n  )</code></pre>\n<p>De plus, vous pouvez par habitude être tenté d’utiliser un\n<code>Array.prototype.forEach</code> alors que votre scope navigateur inclut\nIE8; seuls des tests sur un vrai browser vous permettront d’identifier le souci.</p>\n<p>Je vous conseille fortement testling, très simple à intégrer dans vos\nmodules, et gratuit pour tout projet open-source.</p>\n<p>Dans le <code>package.json</code> :</p>\n<pre><code class=\"language-json\">{\n  \"<span class=\"hljs-attribute\">testling</span>\": <span class=\"hljs-value\">{\n    \"<span class=\"hljs-attribute\">files</span>\": <span class=\"hljs-value\"><span class=\"hljs-string\">\"test/**/*.js\"</span></span>,\n    \"<span class=\"hljs-attribute\">browsers</span>\": <span class=\"hljs-value\">[\n      <span class=\"hljs-string\">\"ie/9..latest\"</span>,\n      <span class=\"hljs-string\">\"chrome/22..latest\"</span>,\n      <span class=\"hljs-string\">\"firefox/16..latest\"</span>,\n      <span class=\"hljs-string\">\"safari/6..latest\"</span>,\n      <span class=\"hljs-string\">\"opera/11.0..latest\"</span>,\n      <span class=\"hljs-string\">\"iphone/6..latest\"</span>,\n      <span class=\"hljs-string\">\"ipad/6..latest\"</span>,\n      <span class=\"hljs-string\">\"android-browser/latest\"</span>\n    ]\n  </span>}\n</span>}</code></pre>\n<p>Et ajouter un webhook dans l’admin de votre repository GitHub pointant vers</p>\n<blockquote>\n<p><a href=\"http://git.testling.com\">http://git.testling.com</a></p>\n</blockquote>\n<p>Vous pouvez l’utiliser avec tape (son test harness par défaut)\nMocha, QUnit et n’importe quelle bibliothèque\nde test supportant <code>TAP</code> comme indiqué sur\n<a href=\"https://ci.testling.com/guide/custom_libraries\">le site de testling</a>.</p>\n<p>Vous trouverez aussi des alternatives populaires\n<a href=\"http://www.browserstack.com\">similaires</a>,\nou ayant <a href=\"http://karma-runner.github.io\">une approche différente</a>.</p>\n<p>Par ailleurs, si dans votre code il existe des variations entre les navigateurs,\nvous pouvez utiliser du test conditionnel :</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">if</span>(<span class=\"hljs-keyword\">typeof</span> {}.__proto__ == <span class=\"hljs-string\">\"object\"</span>){\n  test.equal(list.__proto__ === <span class=\"hljs-built_in\">Array</span>.prototype, <span class=\"hljs-literal\">false</span>, <span class=\"hljs-string\">\"__proto__ isn't Array.prototype\"</span>)\n} <span class=\"hljs-keyword\">else</span> {\n  test.equal(list <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Array</span>, <span class=\"hljs-literal\">false</span>, <span class=\"hljs-string\">\"Isn't a window Array\"</span>)\n}</code></pre>\n<p>Happy testing!</p>\n<pre><code class=\"language-console\">$ testling\n\nTAP version <span class=\"hljs-number\">13</span>\n<span class=\"hljs-preprocessor\"># tests</span>\nok <span class=\"hljs-number\">1</span> bisous\n\n<span class=\"hljs-number\">1.</span><span class=\"hljs-number\">.1</span>\n<span class=\"hljs-preprocessor\"># tests <span class=\"hljs-number\">1</span></span>\n<span class=\"hljs-preprocessor\"># pass  <span class=\"hljs-number\">1</span></span>\n\n<span class=\"hljs-preprocessor\"># ok</span></code></pre>\n","rawBody":"\nLes tests automatisés en front-end ont longtemps été ignorés,\net le sont encore trop.\n\nÉcrire des tests peut paraître chiant, mais le temps qu'ils rapportent\ncompense largement celui que l'on passe à les écrire.\n\n## Écrire du js testable\n\nPrenons un exemple simple et moche :\n\n```javascript\n//app.js\n;(function(){\n\n  var cart = $(\"#cart\")\n  function addToCart(id){\n    var element = $(\"<li></li>\")\n    element.html(catalog[id])\n    cart.append(element)\n  }\n\n  $(\".js-updateCart\")\n    .on(\"click\", function(eventObject){\n      addToCart($(this).data(\"id\"))\n    })\n\n})()\n```\n\nTester ce code est particulièrement lourd, pour plusieurs raisons :\n\n- les functions à tester ne sont pas accessibles\n- on doit simuler un `click` pour tester un comportement logique.\n- on doit créer un element et modifier son `data-id` à chaque cas souhaité.\n- pour tester `addToCart` on doit aller regarder dans le DOM.\n\n### 1. Rendez accessibles vos méthodes au test runner\n\nVous pouvez utiliser un namespace adéquat.\n\n```javascript\nvar app = window.app = {}\napp.cart = {}\napp.cart.addToCart = function(){ /* … */ }\n```\n\nMais ne souhaitez probablement pas rendre vos méthodes accessibles à la console.\n\nUtilisez un module-system : [browserify](http://browserify.org) ou\n[requirejs](http://requirejs.org) (si vous n'avez pas besoin de chargement\nconditionnel et souhaitez créer un bundle par build, utilisez browserify qui\npossède une syntaxe beaucoup plus sympathique et une codebase réduite, vous\npourrez même `require` depuis un module npm\n[comme on vous l'explique dans un article dédié](/posts/js/browserify-all-the-things/)).\n\n```javascript\nvar $ = require(\"jquery\") // oh, un module npm\n\nmodule.exports = {\n  element : $(\"#cart\"),\n  addToCart : function(){\n    /* … */\n  }\n}\n```\n\nVous pourrez ainsi séparer proprement votre application en modules et les tester individuellement.\n\n### 2. Oui, mais les modules interdépendants alors ?\n\nLà, ça devient un peu plus tricky.\nCe que je conseille à titre personnel c'est d'utiliser des events\npour faire communiquer les différentes parties de l'application.\n\nCela permet d'éviter d'utiliser des mocks d'autres parties de l'application partout.\n\nPar exemple, si je souhaite tester le fait qu'un click sur `.js-updateCart`\ndéclanchera bien `updateCart` :\n\n```javascript\n//view.js\n\n// view est une petite class qui route les events\n// en rendant les listeners accessibles aux tests\n// vous pouvez très facilement en concevoir une\n// à votre goût en quelques lignes de code\nvar view = require(\"../lib/view\")\n\n// eventbus est l'event bus de l'application, il orchestre\n// la communication entre les différents modules\nvar eventbus = require(\"../eventbus\")\n\nvar $ = require(\"jquery\")\n\nmodule.exports = view.extend({\n  element : document.body,\n  events : [\n    {\n      type : \"click\",\n      selector : \".js-addToCart\",\n      listener : \"addToCart\"\n    }\n  ],\n  addToCart : function(eventObject){\n    var target = eventObject.currentTarget\n    var id = $(target).data(\"id\")\n    eventbus.fire(\"addToCart\", {\n      id : id\n    })\n  }\n})\n```\n\net je n'aurais qu'à écouter cet event depuis `cart` :\n\n```javascript\n// cart.js\nvar eventbus = require(\"../eventbus\")\nvar catalog = require(\"../catalog\")\n\nmodule.exports = {\n  initialize : function(){\n    this._addToCart = this.addToCart.bind(this)\n    eventbus.listen(\"addToCart\", this._addToCart)\n  },\n  release : function(){\n    eventbus.stopListening(\"addToCart\", this._addToCart)\n  },\n  addToCart : function(eventObject){\n    // et on a eventObject.id\n    this.products.push(catalog[eventObject.currentTarget.data(\"id\")])\n  }\n}\n```\n\nGrâce à cette architecture, je vais pouvoir tester individuellement\nles deux modules.\n\n```javascript\n// view.test.js\n\nvar tape = require(\"tape\")\nvar view = require(\"../app/view\")\nvar eventbus = require(\"../eventbus\")\nvar $ = require(\"jquery\")\n\ntape(\"view\", function(test){\n  test.plan(1)\n  var element = $(\"<div></div>\")\n  element.data(\"id\", 1)\n  // on teste facilement l'envoi\n  eventbus.listen(\"addToCart\", function(eventObject){\n    test.equal(eventObject.id, 1)\n  })\n  view.addToCart({\n    currentTarget : element\n  })\n})\n```\n\n```javascript\n// cart.test.js\n\nvar tape = require(\"tape\")\nvar cart = require(\"../app/cart\")\nvar eventbus = require(\"../eventbus\")\nvar catalog = require(\"../catalog\")\n\ntape(\"cart\", function(test){\n  cart.initialize()\n  eventbus.fireSync(\"addToCart\", {id:1})\n  test.deepEqual(\n    cart[0],\n    catalog[1],\n    \"receives addToCart event\"\n  )\n  test.end()\n})\n```\n\n## Tester tous les cas possibles\n\nCe sont souvent les edge-cases qui nous font nous arracher les cheveux.\nPour pallier ces soucis, tester en profondeur est essentiel.\n\nPrenons un exemple, une méthode qui teste si la valeur qu'on lui passe est\nune `string`.\n\nOn serait tenté de simplement tester les résultats positifs de cette façon :\n\n```javascript\ntape(\"type.isString on strings\", function(test){\n  test.equal(type.isString(\"\"), true)\n  test.end()\n})\n```\n\nOr, si par mégarde ma méthode `isString` se révèle être :\n\n```javascript\ntype.isString = function(value) {\n  return typeof value == \"string\"\n}\n```\n\non ne vérifie pas le cas `type.isString(new String(\"\"))`.\n\nDu coup, des tests complets :\n\n```javascript\ntape(\"type.isString on strings\", function(test){\n  test.equal(type.isString(\"\"), true)\n  test.equal(type.isString(new String(\"\")), false)\n  test.end()\n})\n```\n\npermettent ici d'identifier qu'en réalité on a besoin de :\n\n```javascript\ntype.isString = function(value) {\n  return Object.prototype.toString.call(value) == \"[object String]\"\n}\n```\n\nEt c'est à la force des résultats de tests que vous identifierez rapidement\nvous familiariserez à tous ces edge-cases.\n\nÀ chaque correctif de bug, ajoutez des tests (mais ça, vous le saviez déjà).\n\n## Cross-browser testing\n\nÀ l'heure actuelle, où l'on se trouve notamment très souvent avec du\nfeature testing.\nPour le tester complètement, on doit se servir de vrais navigateurs :\nun headless (certes, très pratique) comme [phantomjs](http://phantomjs.org)\nne permettra pas d'obtenir 100% de coverage.\n\n```javascript\nvar supportsAnimationFrame =\n  !!(\n    win.requestAnimationFrame ||\n    win.webkitRequestAnimationFrame ||\n    win.mozRequestAnimationFrame ||\n    win.ORequestAnimationFrame ||\n    // vous avez fait une faute de frappe,\n    // et mis un `O` majuscule, seul un\n    // test sur les version concernées d'Opera\n    // vous permettront de l'identifier\n    win.msRequestAnimationFrame\n  )\n```\n\nDe plus, vous pouvez par habitude être tenté d'utiliser un\n`Array.prototype.forEach` alors que votre scope navigateur inclut\nIE8; seuls des tests sur un vrai browser vous permettront d'identifier le souci.\n\nJe vous conseille fortement testling, très simple à intégrer dans vos\nmodules, et gratuit pour tout projet open-source.\n\nDans le `package.json` :\n\n```json\n{\n  \"testling\": {\n    \"files\": \"test/**/*.js\",\n    \"browsers\": [\n      \"ie/9..latest\",\n      \"chrome/22..latest\",\n      \"firefox/16..latest\",\n      \"safari/6..latest\",\n      \"opera/11.0..latest\",\n      \"iphone/6..latest\",\n      \"ipad/6..latest\",\n      \"android-browser/latest\"\n    ]\n  }\n}\n```\n\nEt ajouter un webhook dans l'admin de votre repository GitHub pointant vers\n\n> http://git.testling.com\n\nVous pouvez l'utiliser avec tape (son test harness par défaut)\nMocha, QUnit et n'importe quelle bibliothèque\nde test supportant `TAP` comme indiqué sur\n[le site de testling](https://ci.testling.com/guide/custom_libraries).\n\nVous trouverez aussi des alternatives populaires\n[similaires](http://www.browserstack.com),\nou ayant [une approche différente](http://karma-runner.github.io).\n\nPar ailleurs, si dans votre code il existe des variations entre les navigateurs,\nvous pouvez utiliser du test conditionnel :\n\n```javascript\nif(typeof {}.__proto__ == \"object\"){\n  test.equal(list.__proto__ === Array.prototype, false, \"__proto__ isn't Array.prototype\")\n} else {\n  test.equal(list instanceof Array, false, \"Isn't a window Array\")\n}\n```\n\nHappy testing!\n\n```console\n$ testling\n\nTAP version 13\n# tests\nok 1 bisous\n\n1..1\n# tests 1\n# pass  1\n\n# ok\n```\n","raw":"---\ndate: \"2014-05-01\"\ntitle: Introduction au testing js front\ntags:\n  - javascript\n  - tape\n  - unit-test\n  - browserify\nauthors:\n  - bloodyowl\n---\n\nLes tests automatisés en front-end ont longtemps été ignorés,\net le sont encore trop.\n\nÉcrire des tests peut paraître chiant, mais le temps qu'ils rapportent\ncompense largement celui que l'on passe à les écrire.\n\n## Écrire du js testable\n\nPrenons un exemple simple et moche :\n\n```javascript\n//app.js\n;(function(){\n\n  var cart = $(\"#cart\")\n  function addToCart(id){\n    var element = $(\"<li></li>\")\n    element.html(catalog[id])\n    cart.append(element)\n  }\n\n  $(\".js-updateCart\")\n    .on(\"click\", function(eventObject){\n      addToCart($(this).data(\"id\"))\n    })\n\n})()\n```\n\nTester ce code est particulièrement lourd, pour plusieurs raisons :\n\n- les functions à tester ne sont pas accessibles\n- on doit simuler un `click` pour tester un comportement logique.\n- on doit créer un element et modifier son `data-id` à chaque cas souhaité.\n- pour tester `addToCart` on doit aller regarder dans le DOM.\n\n### 1. Rendez accessibles vos méthodes au test runner\n\nVous pouvez utiliser un namespace adéquat.\n\n```javascript\nvar app = window.app = {}\napp.cart = {}\napp.cart.addToCart = function(){ /* … */ }\n```\n\nMais ne souhaitez probablement pas rendre vos méthodes accessibles à la console.\n\nUtilisez un module-system : [browserify](http://browserify.org) ou\n[requirejs](http://requirejs.org) (si vous n'avez pas besoin de chargement\nconditionnel et souhaitez créer un bundle par build, utilisez browserify qui\npossède une syntaxe beaucoup plus sympathique et une codebase réduite, vous\npourrez même `require` depuis un module npm\n[comme on vous l'explique dans un article dédié](/posts/js/browserify-all-the-things/)).\n\n```javascript\nvar $ = require(\"jquery\") // oh, un module npm\n\nmodule.exports = {\n  element : $(\"#cart\"),\n  addToCart : function(){\n    /* … */\n  }\n}\n```\n\nVous pourrez ainsi séparer proprement votre application en modules et les tester individuellement.\n\n### 2. Oui, mais les modules interdépendants alors ?\n\nLà, ça devient un peu plus tricky.\nCe que je conseille à titre personnel c'est d'utiliser des events\npour faire communiquer les différentes parties de l'application.\n\nCela permet d'éviter d'utiliser des mocks d'autres parties de l'application partout.\n\nPar exemple, si je souhaite tester le fait qu'un click sur `.js-updateCart`\ndéclanchera bien `updateCart` :\n\n```javascript\n//view.js\n\n// view est une petite class qui route les events\n// en rendant les listeners accessibles aux tests\n// vous pouvez très facilement en concevoir une\n// à votre goût en quelques lignes de code\nvar view = require(\"../lib/view\")\n\n// eventbus est l'event bus de l'application, il orchestre\n// la communication entre les différents modules\nvar eventbus = require(\"../eventbus\")\n\nvar $ = require(\"jquery\")\n\nmodule.exports = view.extend({\n  element : document.body,\n  events : [\n    {\n      type : \"click\",\n      selector : \".js-addToCart\",\n      listener : \"addToCart\"\n    }\n  ],\n  addToCart : function(eventObject){\n    var target = eventObject.currentTarget\n    var id = $(target).data(\"id\")\n    eventbus.fire(\"addToCart\", {\n      id : id\n    })\n  }\n})\n```\n\net je n'aurais qu'à écouter cet event depuis `cart` :\n\n```javascript\n// cart.js\nvar eventbus = require(\"../eventbus\")\nvar catalog = require(\"../catalog\")\n\nmodule.exports = {\n  initialize : function(){\n    this._addToCart = this.addToCart.bind(this)\n    eventbus.listen(\"addToCart\", this._addToCart)\n  },\n  release : function(){\n    eventbus.stopListening(\"addToCart\", this._addToCart)\n  },\n  addToCart : function(eventObject){\n    // et on a eventObject.id\n    this.products.push(catalog[eventObject.currentTarget.data(\"id\")])\n  }\n}\n```\n\nGrâce à cette architecture, je vais pouvoir tester individuellement\nles deux modules.\n\n```javascript\n// view.test.js\n\nvar tape = require(\"tape\")\nvar view = require(\"../app/view\")\nvar eventbus = require(\"../eventbus\")\nvar $ = require(\"jquery\")\n\ntape(\"view\", function(test){\n  test.plan(1)\n  var element = $(\"<div></div>\")\n  element.data(\"id\", 1)\n  // on teste facilement l'envoi\n  eventbus.listen(\"addToCart\", function(eventObject){\n    test.equal(eventObject.id, 1)\n  })\n  view.addToCart({\n    currentTarget : element\n  })\n})\n```\n\n```javascript\n// cart.test.js\n\nvar tape = require(\"tape\")\nvar cart = require(\"../app/cart\")\nvar eventbus = require(\"../eventbus\")\nvar catalog = require(\"../catalog\")\n\ntape(\"cart\", function(test){\n  cart.initialize()\n  eventbus.fireSync(\"addToCart\", {id:1})\n  test.deepEqual(\n    cart[0],\n    catalog[1],\n    \"receives addToCart event\"\n  )\n  test.end()\n})\n```\n\n## Tester tous les cas possibles\n\nCe sont souvent les edge-cases qui nous font nous arracher les cheveux.\nPour pallier ces soucis, tester en profondeur est essentiel.\n\nPrenons un exemple, une méthode qui teste si la valeur qu'on lui passe est\nune `string`.\n\nOn serait tenté de simplement tester les résultats positifs de cette façon :\n\n```javascript\ntape(\"type.isString on strings\", function(test){\n  test.equal(type.isString(\"\"), true)\n  test.end()\n})\n```\n\nOr, si par mégarde ma méthode `isString` se révèle être :\n\n```javascript\ntype.isString = function(value) {\n  return typeof value == \"string\"\n}\n```\n\non ne vérifie pas le cas `type.isString(new String(\"\"))`.\n\nDu coup, des tests complets :\n\n```javascript\ntape(\"type.isString on strings\", function(test){\n  test.equal(type.isString(\"\"), true)\n  test.equal(type.isString(new String(\"\")), false)\n  test.end()\n})\n```\n\npermettent ici d'identifier qu'en réalité on a besoin de :\n\n```javascript\ntype.isString = function(value) {\n  return Object.prototype.toString.call(value) == \"[object String]\"\n}\n```\n\nEt c'est à la force des résultats de tests que vous identifierez rapidement\nvous familiariserez à tous ces edge-cases.\n\nÀ chaque correctif de bug, ajoutez des tests (mais ça, vous le saviez déjà).\n\n## Cross-browser testing\n\nÀ l'heure actuelle, où l'on se trouve notamment très souvent avec du\nfeature testing.\nPour le tester complètement, on doit se servir de vrais navigateurs :\nun headless (certes, très pratique) comme [phantomjs](http://phantomjs.org)\nne permettra pas d'obtenir 100% de coverage.\n\n```javascript\nvar supportsAnimationFrame =\n  !!(\n    win.requestAnimationFrame ||\n    win.webkitRequestAnimationFrame ||\n    win.mozRequestAnimationFrame ||\n    win.ORequestAnimationFrame ||\n    // vous avez fait une faute de frappe,\n    // et mis un `O` majuscule, seul un\n    // test sur les version concernées d'Opera\n    // vous permettront de l'identifier\n    win.msRequestAnimationFrame\n  )\n```\n\nDe plus, vous pouvez par habitude être tenté d'utiliser un\n`Array.prototype.forEach` alors que votre scope navigateur inclut\nIE8; seuls des tests sur un vrai browser vous permettront d'identifier le souci.\n\nJe vous conseille fortement testling, très simple à intégrer dans vos\nmodules, et gratuit pour tout projet open-source.\n\nDans le `package.json` :\n\n```json\n{\n  \"testling\": {\n    \"files\": \"test/**/*.js\",\n    \"browsers\": [\n      \"ie/9..latest\",\n      \"chrome/22..latest\",\n      \"firefox/16..latest\",\n      \"safari/6..latest\",\n      \"opera/11.0..latest\",\n      \"iphone/6..latest\",\n      \"ipad/6..latest\",\n      \"android-browser/latest\"\n    ]\n  }\n}\n```\n\nEt ajouter un webhook dans l'admin de votre repository GitHub pointant vers\n\n> http://git.testling.com\n\nVous pouvez l'utiliser avec tape (son test harness par défaut)\nMocha, QUnit et n'importe quelle bibliothèque\nde test supportant `TAP` comme indiqué sur\n[le site de testling](https://ci.testling.com/guide/custom_libraries).\n\nVous trouverez aussi des alternatives populaires\n[similaires](http://www.browserstack.com),\nou ayant [une approche différente](http://karma-runner.github.io).\n\nPar ailleurs, si dans votre code il existe des variations entre les navigateurs,\nvous pouvez utiliser du test conditionnel :\n\n```javascript\nif(typeof {}.__proto__ == \"object\"){\n  test.equal(list.__proto__ === Array.prototype, false, \"__proto__ isn't Array.prototype\")\n} else {\n  test.equal(list instanceof Array, false, \"Isn't a window Array\")\n}\n```\n\nHappy testing!\n\n```console\n$ testling\n\nTAP version 13\n# tests\nok 1 bisous\n\n1..1\n# tests 1\n# pass  1\n\n# ok\n```\n","__filename":"posts/js/introduction-au-testing-js-front/index.md","__url":"/posts/js/introduction-au-testing-js-front/"}